/* this task is the driver for the DM7304 power IC */

#include "multi-task.h"
#include "FreeRTOS.h"
#include "task4.h"
#include "stm32f4xx_spi.h"
#include "init.h"
#include "stdio.h"
#include "string.h"
#include "debug.h"

#define PCA9555_IN_REG			0x0
#define PCA9555_OUT_REG			0x2
#define PCA9555_POLARITY_REG	0x4
#define PCA9555_CONFIG_REG		0x6


//#define TASK4_DEBUG         1
typedef enum
{
	IDLE = 0,
	INIT,

}DPM_Task_Status_t;

StackType_t Task4Stack[TASK4_STACK_SIZE] CCM_RAM;  // Put task stack in CCM
StaticTask_t Task4Buffer CCM_RAM;  // Put TCB in CCM

static uint8_t CRC_BUFFER[72];

static uint8_t reg_dpm_cache1[0x96];
static uint8_t reg_pol_cache1[32];
static uint32_t Dpm_Flags=0;

static Pol_Status_t pol_status;
static Pol_PSS_t pol_pss;
static DPM_RSM_t dpm_status;

static uint32_t PCA9555_Out = 0;
static uint32_t PCA9555_In = 0;
static uint32_t PCA9555_Config = 0;
static uint32_t PCA9555_In_Lsb = 0;
static uint32_t PCA9555_In_Hsb = 0;
static uint16_t PCA9555_Out_Flag = 0;
static uint16_t PCA9555_Cfg_Flag = 0;
static uint16_t PCA9555_In_Flag = 0;

static uint8_t Lm92Addrs[] = {
		LM92_TEMPERATURE1_ADDRESS,
		LM92_TEMPERATURE2_ADDRESS,
		LM92_TEMPERATURE3_ADDRESS};

static uint32_t LM92_Temperature = 0;
static uint32_t LM92_GET_TEMP_FLAG = 0;
static uint32_t LM92_GET_ID_FLAG = 0;
static uint32_t LM92_SYMBOL_FLAG = 1;

static uint32_t Ina220State = 0;
static uint32_t INA220_GET_MSG_FLAG = 0;

static uint8_t PCA9555Addrs[] = {
        PCA9555_1_ADDRESS,
        PCA9555_2_ADDRESS};

static uint32_t Eeprom_state = 0;
static uint32_t Eeprom_TestAddr = 0;

static uint32_t ADT7461_GET_ID_FLAG = 0;
static uint32_t ADT7461_GET_LOCAL_TEMP_FLAG = 0;
static uint32_t ADT7461_GET_EXTEMP_HIGH_BYTE_FLAG = 0;
static uint32_t ADT7461_GET_EXTEMP_LOW_BYTE_FLAG = 0;

static uint32_t ADT7461_GET_Ex_Offset_H_BYTE_FLAG = 0;
static uint32_t ADT7461_GET_Ex_Offset_L_BYTE_FLAG = 0;
static uint32_t ADT7461_SET_Ex_Offset_FLAG = 0;

static int8_t adt7461_offset_integer = 0;
static uint8_t adt7461_offset_decimal = 0;


/* below table is generated by tool */
static DM7304_RegTable_t DPM_RegTable[] =
{
		{0x0,	0x0},
		{0x1,	0x0},
		{0x2,	0x0},
		{0x3,	0x0},
		{0x4,	0x0},
		{0x5,	0x0},
		{0x6,	0x0},
		{0x7,	0x0},
		{0x8,	0x6},
		{0x9,	0x80},
		{0xA,	0x0},
		{0xB,	0x0},
		{0xC,	0x0},
		{0xD,	0x0},
		{0xE,	0x0},
		{0xF,	0x0},
		{0x10,	0x0},
		{0x11,	0x0},
		{0x12,	0x93},
		{0x13,	0xC0},
		{0x14,	0xFF},
		{0x15,	0xFF},
		{0x16,	0xFF},
		{0x17,	0x0},
		{0x18,	0x0},
		{0x19,	0x0},
		{0x1A,	0x0},
		{0x1B,	0x0},
		{0x1C,	0x0},
		{0x1D,	0x0},
		{0x1E,	0x0},
		{0x1F,	0x0},
		{0x20,	0x0},
		{0x21,	0x0},
		{0x22,	0x0},
		{0x23,	0x0},
		{0x24,	0x0},
		{0x25,	0x0},
		{0x26,	0x0},
		{0x27,	0x2},
		{0x28,	0x14},
		{0x29,	0x0},
		{0x2A,	0x0},
		{0x2B,	0x0},
		{0x2C,	0x0},
		{0x2D,	0x0},
		{0x2E,	0x0},
		{0x2F,	0x0},
		{0x30,	0x0},
		{0x31,	0x0},
		{0x32,	0x0},
		{0x33,	0x0},
		{0x34,	0x0},
		{0x35,	0x0},
		{0x36,	0x0},
		{0x37,	0x0},
		{0x38,	0x0},
		{0x39,	0x0},
		{0x3A,	0x0},
		{0x3B,	0x0},
		{0x3C,	0x0},
		{0x3D,	0x0},
		{0x3E,	0x0},
		{0x3F,	0x0},
		{0x40,	0x0},
		{0x41,	0x0},
		{0x42,	0x0},
		{0x43,	0x0},
		{0x44,	0x0},
		{0x45,	0x0},
		{0x46,	0x0},
		{0x47,	0x0}

};

/* below table is generated by tool */
DM7304_RegTable_t POL_RegTable[] =
{
		{0x0,	0x41},
		{0x1,	0x8},
		{0x2,	0x1},
		{0x3,	0x14},
		{0x4,	0x80},
		{0x5,	0x19},
		{0x6,	0xE},
		{0x7,	0x39},
		{0x8,	0x5B},
		{0x9,	0x40},
		{0xA,	0x32},
		{0xB,	0x19},
		{0xC,	0xA0},
		{0xD,	0x1F},
		{0xE,	0x60},
		{0xF,	0x17},
		{0x10,	0xC0},
		{0x11,	0xB},
		{0x12,	0x2},
		{0x13,	0x7},
		{0x14,	0x4},
		{0x15,	0x0},
		{0x16,	0x0},
		{0x17,	0x0},
		{0x18,	0x0},
		{0x19,	0x0},
		{0x1A,	0x0},
		{0x1B,	0x0},
		{0x1C,	0x7},
		{0x1D,	0x6},
		{0x1E,	0xAF},
		{0x1F,	0xB9}

};


void dpm_setflag(uint32_t flag)
{
	Dpm_Flags |= flag;
}

void dpm_resetflag(uint32_t flag)
{
	Dpm_Flags &= ~flag;
}

int dpm_getflag(uint32_t flag)
{
	return (Dpm_Flags & flag)?1:0;
}

/* if  delay 239ms */
void delay(int time)
{
	int count;
	while(time-->0)
	{
		count = 10000000;
		while(count--);
	}
}

#define CRC_POLYNOM 0x1021 // x^16 + x^12 + x^5 + 1
unsigned short dpm_crc_calculation(unsigned char* memory, int memory_size)
{
	int i, j;
	unsigned char data;
	unsigned short crc = ((unsigned short) (memory[0]) << 8)
			+ (unsigned short) (memory[1]);
	for (i = 2; i < memory_size; i++) {
		data = memory[i];
		for (j = 0x80; j > 0x00; j = j >> 1) {
			if (crc & 0x8000) {
				crc = crc << 1;
				if (data & j)
					crc |= 0x0001;
				crc ^= CRC_POLYNOM;
			} else {
				crc = crc << 1;
				if (data & j)
					crc |= 0x0001;
			}
		}
	}
	return crc;
}

/*******************************************************************************
 * name: I2C_Transmit
 * in: bus -> I2Cx bus pointer
 *     data -> structure containing transmit direction, read/write direction, length ...
 * out: 0 if no error, else none 0
 * role: write or read data from the slave
*******************************************************************************/
uint32_t I2C_Transmit(I2C_TypeDef * bus, I2C_TransmiData_t data)
{
	static uint32_t lock = 0;
	uint32_t ret = 0;
	uint32_t timeout = I2C_TIMEOUT_MAX;

	/* in case multi-thread is using this interface, wait until it finished */
	while(lock);
	lock++;
	/* step 1 -> generate the start bit */
	I2C_GenerateSTART(bus, ENABLE);

	while(!I2C_CheckEvent(bus, I2C_EVENT_MASTER_MODE_SELECT))
	{
		if(!(timeout--))
		{
			ret = 1;
			goto error;
		}
	}

	switch(data.dir)
	{
	default:
	case I2C_ReadOnly:
		if(data.read == NULL)
		{
			goto error;
		}
		/* step 2 -> send the slave address+r */
		timeout = I2C_TIMEOUT_MAX;
		I2C_Send7bitAddress(bus, (uint8_t)((data.slave << 1) | 0x01), I2C_Direction_Receiver);

		while(!I2C_CheckEvent(bus, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
		{
			if(!(timeout--))
			{
				ret = 2;
				goto error;
			}
		}
		/* step 3 -> to receive the data */
		while(data.rLen--)
		{
			if(data.rLen)
			{
				/* ACK to the received byte */
				I2C_AcknowledgeConfig(bus, ENABLE);
			}
			else
			{
				/* not ACK to the last byte*/
				I2C_AcknowledgeConfig(bus, DISABLE);
			}

			/* wait receiving to finish */
			timeout = I2C_TIMEOUT_MAX;
			while(!I2C_CheckEvent(bus, I2C_EVENT_MASTER_BYTE_RECEIVED))
			{
				if(!(timeout--))
				{
					ret = 3;
					goto error;
				}
			}

			*(data.read++) = I2C_ReceiveData(bus);
		}
		break;
	case I2C_WriteOnly:
		if(data.write == NULL)
		{
			goto error;
		}
		/* step 2 -> send the slave address+w */
		timeout = I2C_TIMEOUT_MAX;
		I2C_Send7bitAddress(bus, (uint8_t)((data.slave << 1)), I2C_Direction_Transmitter);

		while(!I2C_CheckEvent(bus, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
		{
			if(!(timeout--))
			{
				ret = 4;
				goto error;
			}
		}

		/* step 3 -> send the data to the slave */
		while(data.wLen--)
		{
			timeout = I2C_TIMEOUT_MAX;
			I2C_SendData(bus, *(data.write++));
			while(!I2C_CheckEvent(bus,I2C_EVENT_MASTER_BYTE_TRANSMITTED))
			{
				if(!(timeout--))
				{
					ret = 5;
					goto error;
				}
			}
		}
		break;
	case I2C_WriteRead:
		if(data.read == NULL || data.write == NULL)
		{
			goto error;
		}
		/* step 2 -> send the slave address+w */
		timeout = I2C_TIMEOUT_MAX;
		I2C_Send7bitAddress(bus, (uint8_t)((data.slave << 1)), I2C_Direction_Transmitter);

		while(!I2C_CheckEvent(bus, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
		{
			if(!(timeout--))
			{
				ret = 6;
				goto error;
			}
		}

		/* step 3 -> send the data to the slave*/
		while(data.wLen--)
		{
			timeout = I2C_TIMEOUT_MAX;
			I2C_SendData(bus, *(data.write++));
			while(!I2C_CheckEvent(bus,I2C_EVENT_MASTER_BYTE_TRANSMITTED))
			{
				if(!(timeout--))
				{
					ret = 7;
					goto error;
				}
			}
		}

		/* step 4 -> generate a restart bit */
		bus->SR1 |= (uint16_t)0x0400; /* Clear AF flag if arised */
		I2C_GenerateSTART(bus, ENABLE);

		timeout = I2C_TIMEOUT_MAX;
		while(!I2C_CheckEvent(bus, I2C_EVENT_MASTER_MODE_SELECT))
		{
			if(!(timeout--))
			{
				ret = 8;
				goto error;
			}
		}

		/* step 5 -> send the slave address+r */
		I2C_Send7bitAddress(bus, (uint8_t)((data.slave << 1)|0x01), I2C_Direction_Receiver);

		timeout = I2C_TIMEOUT_MAX;
		while(!I2C_CheckEvent(bus, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))
		{
			if(!(timeout--))
			{
				ret = 9;
				goto error;
			}
		}


		/* step 6 -> to receive the data */
		while(data.rLen--)
		{
			if(data.rLen)
			{
				/* ACK to the received byte */
				I2C_AcknowledgeConfig(bus, ENABLE);
			}
			else
			{
				/* not ACK to the last byte*/
				I2C_AcknowledgeConfig(bus, DISABLE);
			}

			timeout = I2C_TIMEOUT_MAX;
			while(!I2C_CheckEvent(bus, I2C_EVENT_MASTER_BYTE_RECEIVED))
			{
				if(!(timeout--))
				{
					ret = 10;
					goto error;
				}
			}

			*(data.read++) = I2C_ReceiveData(bus);
		}

		break;
	}
error:
	/* step n -> send the stop bit */
	I2C_GenerateSTOP(bus, ENABLE);
	lock--;
	return ret;
}

/*******************************************************************************
 * name: DM7304Reset
 * in: void
 * out: void
 * role: reset DM7304
*******************************************************************************/
void DM7304Reset(void)
{
	GPIO_ResetBits(GPIOI, GPIO_Pin_8); /* POWERVDD_RESET_N*/
	GPIO_ResetBits(GPIOC, GPIO_Pin_15);/* POWERVDD_HRESET_N */
	GPIO_ResetBits(GPIOC, GPIO_Pin_13);/* POWERVDD_INT0_N */
}

/*******************************************************************************
 * name: DM7304Release
 * in: void
 * out: void
 * role: release the DM7304
*******************************************************************************/
void DM7304Release(void)
{
	GPIO_SetBits(GPIOI, GPIO_Pin_8);/* POWERVDD_RESET_N*/
	GPIO_SetBits(GPIOC, GPIO_Pin_15);/* POWERVDD_HRESET_N*/
	GPIO_SetBits(GPIOC, GPIO_Pin_13);/* POWERVDD_INT0_N*/
}

/*******************************************************************************
 * name: dpm_rrp
 * in: r -> register's address
 *     data -> point to element which keep the received data
 * return: 0 if success, else non 0
 * role: Read Data d from Register r of POL 0 using RRP command
*******************************************************************************/
int dpm_rrp(uint8_t r, uint8_t *data)
{
	I2C_TransmiData_t pack;
	uint8_t write[3];
	uint8_t read[2];
	int ret = 0;

	write[0] = RRP_OPCODE;
	/* POL is 0 */
	write[1] = 0;
	write[2] = r;

	pack.dir   = I2C_WriteRead;
	pack.slave = DM7304_ADDRESS;
	pack.wLen  = sizeof(write);
	pack.rLen  = sizeof(read);
	pack.write = write;
	pack.read  = read;

	ret = I2C_Transmit(I2C2, pack);

	*data = read[0];

	if(ret ||  (read[1] != DPM_SUCCESS))
	{
		ret = 1;
	}

	return ret;
}

/*******************************************************************************
 * name: dpm_wrp
 * in: r -> register's address
 *     d -> data set to that register
 * return: 0 if success, else non 0
 * role: Write Data d into Register r of POL 1 using the WRP command
*******************************************************************************/
int dpm_wrp(uint8_t r, uint8_t d)
{
	I2C_TransmiData_t pack;
	uint8_t write[7];
	uint8_t read;
	int ret = 0;

	write[0] = WRP_OPCODE;
	/* POL mask, only POL0 is present, bit0 is set */
	write[1] = 0x01;
	write[2] = 0x00;
	write[3] = 0x00;
	write[4] = 0x00;
	write[5] = r;
	write[6] = d;

	pack.dir   = I2C_WriteRead;
	pack.slave = DM7304_ADDRESS;
	pack.wLen  = sizeof(write);
	pack.rLen  = sizeof(read);
	pack.write = write;
	pack.read  = &read;

	ret = I2C_Transmit(I2C2, pack);

	if(ret || (read != DPM_SUCCESS))
	{
		/* write command failed */
		ret = 1;
	}

	return ret;

}

/*******************************************************************************
 * name: dpm_wrm
 * in: r -> register's address
 *     d -> data set to that register
 * return: 0 if success, else non 0
 * role: Write Data d into DPM register r(RAM) using the WRM command
*******************************************************************************/
int dpm_wrm(uint8_t r, uint8_t d)
{
	I2C_TransmiData_t pack;
	uint8_t write[3];
	uint8_t read;
	int ret = 0;

	write[0] = WRM_OPCODE;
	write[1] = r;
	write[2] = d;

	pack.dir   = I2C_WriteRead;
	pack.slave = DM7304_ADDRESS;
	pack.wLen  = sizeof(write);
	pack.rLen  = sizeof(read);
	pack.write = write;
	pack.read  = &read;

	ret = I2C_Transmit(I2C2, pack);

	if(ret || (read != DPM_SUCCESS))
	{
		/* write command failed */
		ret = 1;
	}

	return ret;
}


/*******************************************************************************
 * name: dpm_rrm
 * in: r -> register's address
 *     d -> pointer to keep the received data
 * out: 0 if success, else non 0
 * role: Read Data d from DPM register r (RAM), using the RRM command
*******************************************************************************/
int dpm_rrm(uint8_t r, uint8_t *d)
{
	I2C_TransmiData_t pack;
	uint8_t write[2];
	uint8_t read[2];
	int ret = 0;

	write[0] = RRM_OPCODE;
	write[1] = r;

	pack.dir   = I2C_WriteRead;
	pack.slave = DM7304_ADDRESS;
	pack.wLen  = sizeof(write);
	pack.rLen  = sizeof(read);
	pack.write = write;
	pack.read  = read;

	ret = I2C_Transmit(I2C2, pack);

	if(ret || (read[1] != DPM_SUCCESS))
	{
		/* write command failed */
		ret = 1;
	}

	*d = read[0];

	return ret;
}

/*******************************************************************************
 * name: dpm_wsr
 * in: r -> register's address
 *     d -> data write to that register
 * out: 0 if success, else non 0
 * role: Write Data d into POL Setup Register r (RAM), using the WSR command
*******************************************************************************/
int dpm_wsr(uint8_t r, uint8_t d)
{
	I2C_TransmiData_t pack;
	uint8_t write[3];
	uint8_t read;
	int ret = 0;

	write[0] = WSR_OPCODE;
	write[1] = r;
	write[2] = d;

	pack.dir   = I2C_WriteRead;
	pack.slave = DM7304_ADDRESS;
	pack.wLen  = sizeof(write);
	pack.rLen  = sizeof(read);
	pack.write = write;
	pack.read  = &read;

	ret = I2C_Transmit(I2C2, pack);

	if(ret || (read != DPM_SUCCESS))
	{
		/* write command failed */
		ret = 1;
	}

	return ret;
}

/*******************************************************************************
 * name: dpm_wsr
 * in: pol -> the POL index number
 * out: 0 if success, else non 0
 * role: Store POL p Setup Register Block into Flash using the SSR command
*******************************************************************************/
int dpm_ssr(uint8_t pol)
{
	I2C_TransmiData_t pack;
	uint8_t write[2];
	uint8_t read;
	int ret = 0;

	write[0] = SSR_OPCODE;
	write[1] = pol;

	pack.dir   = I2C_WriteRead;
	pack.slave = DM7304_ADDRESS;
	pack.wLen  = sizeof(write);
	pack.rLen  = sizeof(read);
	pack.write = write;
	pack.read  = &read;

	ret = I2C_Transmit(I2C2, pack);

	if(ret || (read != DPM_SUCCESS))
	{
		/* write command failed */
		ret = 1;
	}

	return ret;
}

/*******************************************************************************
 * name: dpm_srm
 * in: crc0 -> low byte of the CRC value
 * 	   crc1 -> high byte of the CRC value
 * out: 0 if success, else non 0
 * role: Store DPM registers into Flash with the given CRC protection with the SRM
 * 		 command
*******************************************************************************/
int dpm_srm(uint8_t crc0, uint8_t crc1)
{
	I2C_TransmiData_t pack;
	uint8_t write[3];
	uint8_t read;
	int ret = 0;

	write[0] = SRM_OPCODE;
	write[1] = crc0;
	write[2] = crc1;

	pack.dir   = I2C_WriteRead;
	pack.slave = DM7304_ADDRESS;
	pack.wLen  = sizeof(write);
	pack.rLen  = sizeof(read);
	pack.write = write;
	pack.read  = &read;

	ret = I2C_Transmit(I2C2, pack);

	if(ret || (read != DPM_SUCCESS))
	{
		/* write command failed */
		ret = 1;
	}

	return ret;
}

/*******************************************************************************
 * name: dpm_crc
 * in: pol -> the POL mask
 * out: 0 if success, else non 0
 * role: POL a Memory CRC check for the given POL using the CRC command
*******************************************************************************/
int dpm_crc(uint32_t pol)
{
	I2C_TransmiData_t pack;
	uint8_t write[5];
	uint8_t read;
	int ret = 0;

	write[0] = CRC_OPCODE;
	/* POL mask */
	write[1] = (uint8_t)(pol & 0xff);
	write[2] = (uint8_t)((pol>>8) & 0xff);
	write[3] = (uint8_t)((pol>>16) & 0xff);
	write[4] = (uint8_t)((pol>>24) & 0xff);

	pack.dir   = I2C_WriteRead;
	pack.slave = DM7304_ADDRESS;
	pack.wLen  = sizeof(write);
	pack.rLen  = sizeof(read);
	pack.write = write;
	pack.read  = &read;

	ret = I2C_Transmit(I2C2, pack);

	if(ret || (read != DPM_SUCCESS))
	{
		/* write command failed */
		ret = 1;
	}

	return ret;
}

/*******************************************************************************
 * name: dpm_lsr
 * in: pol -> the POL index
 * out: 0 if success, else non 0
 * role: load the pol's configuration from flash to its RAM using the LSR command
*******************************************************************************/
int dpm_lsr(uint8_t pol)
{
	I2C_TransmiData_t pack;
	uint8_t write[2];
	uint8_t read;
	int ret = 0;

	write[0] = LSR_OPCODE;
	write[1] = pol;

	pack.dir   = I2C_WriteRead;
	pack.slave = DM7304_ADDRESS;
	pack.wLen  = sizeof(write);
	pack.rLen  = sizeof(read);
	pack.write = write;
	pack.read  = &read;

	ret = I2C_Transmit(I2C2, pack);

	if(ret || (read != DPM_SUCCESS))
	{
		/* write command failed */
		ret = 1;
	}

	return ret;
}

/*******************************************************************************
 * name: dpm_disable_wp
 * in: new_wp_value -> the new value set to WP register
 * out: 0 if success, else non 0
 * role: write value to the WP register
*******************************************************************************/
int dpm_disable_wp(uint8_t new_wp_value)
{
	uint8_t tmp;
	int error = 0;
	/* Disable using Write-Protect register 0x96 */
	if ((dpm_wrm(DPM_WP, new_wp_value)) < 0) {
		//printf("Disable Write-Protect register failed\n");
		return -1;
	}
	/* read back the wp reg */
	if (!dpm_rrm(0x96, &tmp)) {
		if (new_wp_value != tmp) {
			error = 1;
		}
	}
	else
	{
		error = 2;
	}
	return error;
}

/*******************************************************************************
 * name: dpm_run
 * in: en -> 1: enable output, 0 disable output
 * out: 0 if success, else non 0
 * role: enable/disable the output
*******************************************************************************/
int dpm_run(uint8_t en)
{
	dpm_disable_wp(8);//by pass dpm
	return dpm_wrp(0x15, !!en);//enable output
}

/*******************************************************************************
 * name: dpm_rmdp
 * in: pol -> POL index
 *     status -> point to element which store the status information for that POL
 * out: 0 if success, else non 0
 * role: read the specified POL's status by the RMDP command
*******************************************************************************/
int dpm_rmdp(uint8_t pol, Pol_Status_t *status)
{
	I2C_TransmiData_t pack;
	uint8_t write[2];
	uint8_t read[6];
	int ret = 0;

	write[0] = RMDP_OPCODE;
	write[1] = pol;

	pack.dir   = I2C_WriteRead;
	pack.slave = DM7304_ADDRESS;
	pack.wLen  = sizeof(write);
	pack.rLen  = sizeof(read);
	pack.write = write;
	pack.read  = read;

	ret = I2C_Transmit(I2C2, pack);

	if(ret || (read[5] != DPM_SUCCESS))
	{
		/* write command failed */
		ret = 1;
	}
	else
	{
		status->st = read[0];
		status->vh = read[1];
		status->vl = read[2];
		status->io = read[3];
		status->tmp = read[4];
	}

	return ret;
}

/*******************************************************************************
 * name: dpm_rsm
 * in: data -> point to element which store the status of the DPM
 * out: 0 if success, else non 0
 * role: read the specified DPM's status by the RSM command
*******************************************************************************/
int dpm_rsm(DPM_RSM_t *data)
{
	I2C_TransmiData_t pack;
	uint8_t write;
	uint8_t read[7];
	int ret = 0;

	write = RSM_OPCODE;

	pack.dir   = I2C_WriteRead;
	pack.slave = DM7304_ADDRESS;
	pack.wLen  = sizeof(write);
	pack.rLen  = sizeof(read);
	pack.write = &write;
	pack.read  = read;

	ret = I2C_Transmit(I2C2, pack);

	if(ret || (read[6] != DPM_SUCCESS))
	{
		/* write command failed */
		ret = 1;
	}
	else
	{
		data->sta = read[0];
		data->stb = read[1];
		data->stc = read[2];
		data->std = read[3];
		data->dpms = read[4];
		data->est = read[5];
	}

	return ret;
}

/*******************************************************************************
 * name: dpm_rpss
 * in: data -> point to element which store the status of PPS
 * out: 0 if success, else non 0
 * role: read the POL's PPS status by the RPSS command
*******************************************************************************/
int dpm_rpss(Pol_PSS_t *data)
{
	I2C_TransmiData_t pack;
	uint8_t write;
	uint8_t read[5];
	int ret = 0;

	write = RPSS_OPCODE;

	pack.dir   = I2C_WriteRead;
	pack.slave = DM7304_ADDRESS;
	pack.wLen  = sizeof(write);
	pack.rLen  = sizeof(read);
	pack.write = &write;
	pack.read  = read;

	ret = I2C_Transmit(I2C2, pack);

	if(ret || (read[4] != DPM_SUCCESS))
	{
		/* write command failed */
		ret = 1;
	}
	else
	{
		data->pss0 = read[0];
		data->pss0 = read[1];
		data->pss0 = read[2];
		data->pss0 = read[3];
	}

	return ret;
}

/*******************************************************************************
 * name: dpm_program_dpm
 * in: void
 * out: 0 if success, else non 0
 * role: program the DPM, configuration was done by array DPM_RegTable, this table
 *       should be generated by tool, the tool does not provide the CRC. we need
 *       to calculate the CRC by calling dpm_crc_calculation
*******************************************************************************/
int dpm_program_dpm(void)
{
	int i;
	uint8_t crc0, crc1;
	unsigned short crc;
	int error = 0;

	for(i=0; i<sizeof(DPM_RegTable)/sizeof(DPM_RegTable[0]); i++)
	{
		/* skip two bytes of ID */
		if(i<0x15)
		{
			CRC_BUFFER[i] = DPM_RegTable[i].value;
		}
		else
		{
			CRC_BUFFER[i] = DPM_RegTable[i+2].value;
		}
	}
	CRC_BUFFER[70] = 0; /* dump byte */
	CRC_BUFFER[71] = 0; /* dump byte */

	crc = dpm_crc_calculation(CRC_BUFFER, 72); /* total 72 bytes */
	crc0 = (uint8_t)(crc & 0xff);
	crc1 = (uint8_t)((crc>>8) & 0xff);

	/* 72 bytes */
	for(i=0; i<sizeof(DPM_RegTable)/sizeof(DPM_RegTable[0]); i++)
	{
		/* Two bytes are defined to encode a Power-One and/or Customer ID.
		 * The ID is a continuous 16-bit binary number. These registers are
		 * initialized to 0xFF and can be modified only if they contain an 0xFF.
		 * Once there is at least one ‘0’ bit, the registers turn to read only.?
		 */

		/* skip 0x15 DPM Customer Identification Register */
		if(DPM_RegTable[i].addr == 0x15)
		{
			continue;
		}
		/* skip 0x16 DPM Customer Identification Register */
		if(DPM_RegTable[i].addr == 0x16)
		{
			continue;
		}
		/* write configuration to DPM's registers using the WRM command */
		if(dpm_wrm(DPM_RegTable[i].addr, DPM_RegTable[i].value))
		{
			error = 1;
			break;
		}
		delay(1);
	}

	if(!error)
	{
		delay(10);
		if(dpm_srm(crc0, crc1))
		{
			error = 2;
		}
	}

	return error;
}

/*******************************************************************************
 * name: dpm_program_pol
 * in: void
 * out: 0 if success, else non 0
 * role: program the POL and store the configuration to flash.
 *       the configuration is done by array POL_RegTable, this table
 *       should be generated by tool. the configuration is protected by CRC, the
 *       tool generated the CRC already
*******************************************************************************/
int dpm_program_pol(void)
{
	int i;
	int error = 0;
#ifdef POL_CRC_CALCULATION
	uint8_t crc0, crc1;
	unsigned short crc;

	for(i=0; i<sizeof(POL_RegTable)/sizeof(POL_RegTable[0]); i++)
	{
		CRC_BUFFER[i] = POL_RegTable[i].value;
	}
	CRC_BUFFER[23] = 0;
	CRC_BUFFER[24] = 0; /* total 25 bytes */

	crc = dpm_crc_calculation(CRC_BUFFER, 25);
	crc0 = (uint8_t)(crc & 0xff);
	crc1 = (uint8_t)((crc>>8) & 0xff);
#endif /*POL_CRC_CALCULATION*/

	for(i=0; i<sizeof(POL_RegTable)/sizeof(POL_RegTable[0]); i++)
	{
		/* write configuration to POL's setup registers using the WSR command */
		if(dpm_wsr(POL_RegTable[i].addr, POL_RegTable[i].value))
		{
			error = 1;
			break;
		}
		delay(1);
	}
#if POL_CRC_CALCULATION /* in case crc0 crc1 not in the table */
	if(!error)
	{
		if(dpm_wsr(0x1e, crc0))
		{
			error = 2;
		}
	}

	if(!error)
	{
		if(dpm_wsr(0x1f, crc1))
		{
			error = 3;
		}
	}

#endif/*POL_CRC_CALCULATION*/
	if(!error)
	{
		delay(10);
		if(dpm_ssr(0)) /* save the configuration to flash using the SSR command */
		{
			error = 4;
		}
	}

	return error;
}

/*******************************************************************************
 * name: dpm_program_pol_ram
 * in: void
 * out: 0 if success, else non 0
 * role: program the POL in its RAM, BUT do not store the configuration to flash.
*******************************************************************************/
int dpm_program_pol_ram(void)
{
	int i;
	int error = 0;
	uint8_t tmp;

	for(i=0; i<0x15; i++)
	{

		/* write configuration to the POL using the WRP command */
		if(dpm_wrp(POL_RegTable[i].addr, POL_RegTable[i].value))
		{
			error = 1;
			break;
		}
	}

	/* run enable */
	tmp = 1;
	if(dpm_wrp(0x15, tmp))
	{
		error = 2;
	}

	/* 0x15 -> enable register */
	if(dpm_rrp(0x15, &tmp))
	{
		error = 3;
	}
	/* 0x16 -> status register */
	if(dpm_rrp(0x16, &tmp))
	{
		error = 4;
	}

	return error;
}

/*******************************************************************************
 * name: zm_dump_pol
 * in: data -> store all the register get from the POL
 *     len -> byte sum to read
 * out: 0 if success, else non 0
 * role: dump len bytes from the POL using the RRP command
*******************************************************************************/
int dpm_dump_pol(uint8_t *data, uint8_t len)
{
	int i;
	int ret = 0;

	for(i=0; i<len; i++)
	{
		 if(dpm_rrp(i, &data[i]))
		 {
			 ret = 1;
			 break;
		 }
	}

	return ret;
}

/*******************************************************************************
 * name: dpm_dump_dpm
 * in: data -> store all the registers get from the DPM
 *     len -> byte sum to read from DPM
 * out: 0 if success, else non 0
 * role: dump len bytes from the DPM using the RRM command
*******************************************************************************/
int dpm_dump_dpm(uint8_t *data, uint8_t len)
{
	int i;
	int ret = 0;

	for(i=0; i<len; i++)
	{
		if(dpm_rrm(i, &data[i]))
		{
			ret = 1;
			break;
		}
	}

	return ret;
}

/*******************************************************************************
 * name: dpm_pol_set_voltage
 * in: vol -> the output voltage in 1mV unit
 *     len -> byte sum to read from DPM
 * out: 0 if success, else non 0
 * role: set the output voltage to the given value
*******************************************************************************/
int dpm_pol_set_voltage(uint32_t vol)
{
	int error  = 0;
	uint32_t vol_l_margin;
	uint32_t vol_h_margin;
	uint8_t vol_hl;
	uint8_t vol_ll;
    
   /* write to write protected register */
    dpm_disable_wp(0x08);
    delay(1);

	vol_l_margin = vol - 55;/* low margin is normal voltage - 55 mV */
	vol_h_margin = vol + 55;/* high margin is normal voltage + 55 mV */

	vol = (vol * 10 / 25) << 4;/* VH,L 12 bit data word, left aligned, 1LSB=2.5mV */
	vol_hl = (uint8_t)((vol >> 8) & 0xff);
	vol_ll = (uint8_t)(vol & 0xff);

	error = dpm_wrp(0x0B, vol_hl);/* First Vo Setpoint High Byte */
	if(error)
	{
		goto out;
	}

	error = dpm_wrp(0x0C, vol_ll);/* First Vo Setpoint Low Byte */
	if(error)
	{
		goto out;
	}

	vol = (vol_h_margin * 10 / 25) << 4;/* VH,L 12 bit data word, left aligned, 1LSB=2.5mV */
	vol_hl = (uint8_t)((vol >> 8) & 0xff);
	vol_ll = (uint8_t)(vol & 0xff);

	error = dpm_wrp(0x0D, vol_hl);/* Second Vo Setpoint High Byte */
	if(error)
	{
		goto out;
	}

	error = dpm_wrp(0x0E, vol_ll);/* Second Vo Setpoint Low Byte */
	if(error)
	{
		goto out;
	}

	vol = (vol_l_margin * 10 / 25) << 4;/* VH,L 12 bit data word, left aligned, 1LSB=2.5mV */
	vol_hl = (uint8_t)((vol >> 8) & 0xff);
	vol_ll = (uint8_t)(vol & 0xff);

	error = dpm_wrp(0x0F, vol_hl);/* Third Vo Setpoint High Byte */
	if(error)
	{
		goto out;
	}

	error = dpm_wrp(0x10, vol_ll);/* Third Vo Setpoint Low Byte */
	if(error)
	{
		goto out;
	}

out:
	return error;
}


int PCA9555_ReadRegs(uint8_t addr, uint32_t *value, uint32_t index)
{
    int ret = 0;
    I2C_TransmiData_t data;
	uint8_t write[2];
	uint8_t read[2];

	write[0] = addr;
	data.dir = I2C_WriteRead;
	data.slave = PCA9555Addrs[index];
	data.write = write;
	data.read  = read;
	data.wLen  = 1;
	data.rLen  = 2;

	ret = I2C_Transmit(I2C2, data);

    *value = *(uint32_t *)read;
	return ret;
}

int PCA9555_WriteRegs(uint8_t addr, uint32_t value, uint32_t index)
{
    int ret = 0;
    I2C_TransmiData_t data;
	uint8_t write[3];
	uint8_t read[2];

	write[0] = addr;
    write[1] = (uint8_t)(value & 0xff);
    write[2] = (uint8_t)((value>>8) & 0xff);
	data.dir = I2C_WriteRead;
	data.slave = PCA9555Addrs[index];
	data.write = write;
	data.read  = read;
	data.wLen  = 3;
	data.rLen  = 2;

	ret = I2C_Transmit(I2C2, data);

    return ret;
}

/*******************************************************************************
 * name: PCA9555_InputOutConfig
 * role: configure the PCA9555 IOs as input/output
 * parameters: config -> 1bit/pin MSB, the value updated to global data PCA9555_Config
 * 			   it will be updated to the chip in a periodic task.
 * note: this function configure the specified pin as input or output
 * 		bit value 0 -> output
 * 		bit value 1 -> input
*******************************************************************************/
int PCA9555_InputOutConfig(uint32_t config)
{
	PCA9555_Config = config;
    PCA9555_Cfg_Flag = 1;
	return 0;
}

/*******************************************************************************
 * name: PCA9555_Output
 * role: configure the PCA9555 IOs' output level
 * parameters: config -> 1bit/pin MSB, the value updated to global data PCA9555_Out
 * 			   it will be updated to the chip in a periodic task.
 * note: this function configure the specified pins' level
 * 		bit value 0 -> Low level
 * 		bit value 1 -> High level
*******************************************************************************/
int PCA9555_Output(uint32_t value)
{
	PCA9555_Out = value;
	PCA9555_Out_Flag = 1;
	return 0;
}

/*******************************************************************************
 * name: PCA9555_Input
 * role: get the PCA9555 IOs' cache level, the update rate depend on the calling
 * 		task's period
 * parameters: void
 * note: this function return the all pins' level
 * 		bit value 0 -> Low level
 * 		bit value 1 -> High level
*******************************************************************************/
int PCA9555_Input(void)
{
	PCA9555_In_Flag = 1;
	return PCA9555_In;
}

/*******************************************************************************
 * name: PCA9555_Management
 * role: manage the PCA9555 extended IO chip
 * parameters: index  , selcet which PCA9555
 * note: called periodically by a task
 * 		if PCA9555_Out is difference with OutCache, this value will update to
 * 		the chip.
 * 		if PCA9555_Config is difference with PCA9555_Config, the configured value
 * 		will update to the chip
 * 		for the Output & CFG data, 1bit/pin MSB
*******************************************************************************/
static uint32_t PCA9555_Management()
{
	static uint32_t OutCache = 0;
	static uint32_t ConfigCache = 0;

    	
	if(PCA9555_Out_Flag)
	{
		PCA9555_WriteRegs(PCA9555_OUT_REG, (PCA9555_Out & 0x0000ffff), 0);
		PCA9555_WriteRegs(PCA9555_OUT_REG, ((PCA9555_Out >> 16) & 0x0000ffff), 1);
		OutCache = PCA9555_Out;
		sprintf((char *)CRC_BUFFER, "PCA9555 output: 0x%08x\r\n", OutCache);
		dbg_printf((char *)CRC_BUFFER);
        PCA9555_Out_Flag = 0;
	}

	if(PCA9555_Cfg_Flag)
	{
		PCA9555_WriteRegs(PCA9555_CONFIG_REG, (PCA9555_Config & 0x0000ffff), 0);
		PCA9555_WriteRegs(PCA9555_CONFIG_REG, ((PCA9555_Config >> 16) & 0x0000ffff), 1);
		ConfigCache = PCA9555_Config;
		sprintf((char *)CRC_BUFFER, "PCA9555 CFG: 0x%08x\r\n", ConfigCache);
		dbg_printf((char *)CRC_BUFFER);
        PCA9555_Cfg_Flag = 0;
	}
    
    if(PCA9555_In_Flag)
    {
	    PCA9555_ReadRegs(PCA9555_IN_REG, &PCA9555_In_Lsb, 0);
	    PCA9555_ReadRegs(PCA9555_IN_REG, &PCA9555_In_Hsb, 1);

        PCA9555_In = (PCA9555_In_Lsb & 0x0000ffff) | ((PCA9555_In_Hsb << 16));
        sprintf((char *)CRC_BUFFER, "PCA9555 input: 0x%x\r\n", PCA9555_In);
	    dbg_printf((char *)CRC_BUFFER);

        PCA9555_In_Flag = 0;
   	}

	return 0;
}



/*******************************************************************************
 * name: LM92ReadTemperature
 * role: read temperature from the LM92 chip
 * parameters: index -> 0/1/2
 * 			   temp -> point to received the temperature
 * out: 0 if no error, else non 0
 * note: get temperature from the LM92 sensor, the raw data is 1LSB for 0.0625 degree
*******************************************************************************/
static int LM92ReadTemperature(uint32_t index, int16_t *temp)
{
	I2C_TransmiData_t data;
	uint32_t ret = 0;
	uint8_t write[2] = {LM92_TEMPERATURE_REG};
	uint8_t read[2]  = {0};
    int16_t temp_data = 0;
	int16_t temperature = 0;
    char sign = ' ';

	data.dir = I2C_WriteRead;
	data.slave = Lm92Addrs[index];
	data.write = write;
	data.read  = read;
	data.wLen  = 1;
	data.rLen  = 2;

	ret = I2C_Transmit(I2C1, data);

	if(!ret)
	{
	    temp_data = ((short)(read[0]) << 8)|(((short)(read[1])) & (0x000000ff));
        temperature = (temp_data >> 3)&0x00001fff;
		*temp = temperature;
        if(temperature & 0x1000)
        {
            temperature = temperature & 0x00000fff; 
            sign = '-';
            LM92_SYMBOL_FLAG = 0;
            
            if(temperature & 0x800)
            {
                temperature = (0x800 << 1) - temperature;
            }
        }
        else 
        {
            sign = '+';
	        LM92_SYMBOL_FLAG = 1;   
        }
    }
#ifdef TASK4_DEBUG
    sprintf((char *)CRC_BUFFER, "LM92 temperature:%c%d.%.4d\n",
                 sign, temperature >> 4, (temperature & 0xF)*625);
    dbg_printf((char *)CRC_BUFFER);
#endif

	return ret;
}

/*******************************************************************************
 * name: LM92Config
 * role: configure the LM92 sensor
 * in: index -> 0/1/2
 * 	   cfg -> BIT0 shutdown
 * 	   		  BIT1 INT mode
 * 	   		  BIT2 T_CRIT_APolarity
 * 	   		  BIT3 INT Polarity
 * 	   		  BIT4 Fault Queue
 * out: 0 IF success, else none 0
*******************************************************************************/
static int32_t LM92Config(uint32_t index, uint8_t cfg)
{
	I2C_TransmiData_t data;
	uint32_t ret = 0;
	uint8_t write[2];

	write[0] = LM92_CFG_REG;
	write[1] = cfg;

	data.dir = I2C_WriteOnly;
	data.slave = Lm92Addrs[index];
	data.write = write;
	data.read  = NULL;
	data.wLen  = 2;
	data.rLen  = 0;

	ret = I2C_Transmit(I2C1, data);

	return ret;
}

/*******************************************************************************
 * name: THsyt
 * role: Set Thsyt parameter to the LM92 chip
 * in: index -> 0/1/2
 * 	   THsyt
 * out: 0 if success else none 0
 * note: the THsyt is left align, the right 3 bit don't care
*******************************************************************************/
static uint32_t LM92SetTHyst(uint32_t index, uint16_t THsyt)
{
	I2C_TransmiData_t data;
	uint32_t ret = 0;
	uint8_t write[3];

	write[0] = LM92_THSYT_REG;
	write[1] = (uint8_t)((THsyt >> 8) & 0xff);
	write[2] = (uint8_t)(THsyt & 0xff);
	data.dir = I2C_WriteOnly;
	data.slave = Lm92Addrs[index];
	data.write = write;
	data.read  = NULL;
	data.wLen  = 3;
	data.rLen  = 0;

	ret = I2C_Transmit(I2C1, data);

	return ret;
}

/*******************************************************************************
 * name: LM92SetTLow
 * role: Set Thsyt parameter to the LM92 chip
 * in: index -> 0/1/2
 * 	   TLow
 * out: 0 if success else none 0
 * note: the TLow is left align, the right 3 bit don't care
*******************************************************************************/
static uint32_t LM92SetTLow(uint32_t index, uint16_t TLow)
{
	I2C_TransmiData_t data;
    uint32_t ret = 0;
	uint8_t write[3];

	write[0] = LM92_TLOW_REG;
	write[1] = (uint8_t)((TLow >> 8) & 0xff);
	write[2] = (uint8_t)(TLow & 0xff);
	data.dir = I2C_WriteOnly;
	data.slave = Lm92Addrs[index];
	data.write = write;
	data.read  = NULL;
	data.wLen  = 3;
	data.rLen  = 0;

	ret = I2C_Transmit(I2C1, data);

	return ret;
}

/*******************************************************************************
 * name: LM92SetTHigh
 * role: Set Thsyt parameter to the LM92 chip
 * in: index -> 0/1/2
 * 	   THigh
 * out: 0 if success else none 0
 * note: the THigh is left align, the right 3 bit don't care
*******************************************************************************/
static uint32_t LM92SetTHigh(uint32_t index, uint16_t THigh)
{
	I2C_TransmiData_t data;
	uint32_t ret = 0;
	uint8_t write[3];

	write[0] = LM92_THIGH_REG;
	write[1] = (uint8_t)((THigh >> 8) & 0xff);
	write[2] = (uint8_t)(THigh & 0xff);
	data.dir = I2C_WriteOnly;
	data.slave = Lm92Addrs[index];
	data.write = write;
	data.read  = NULL;
	data.wLen  = 3;
	data.rLen  = 0;

	ret = I2C_Transmit(I2C1, data);

	return ret;
}

/*******************************************************************************
 * name: LM92SetTCrit
 * role: Set Thsyt parameter to the LM92 chip
 * in: index -> 0/1/2
 * 	   TCrit
 * out: 0 if success else none 0
 * note: the TCrit is left align, the right 3 bit don't care
*******************************************************************************/
static uint32_t LM92SetTCrit(uint32_t index, uint16_t TCrit)
{
	I2C_TransmiData_t data;
	uint32_t ret = 0;
	uint8_t write[3];

	write[0] = LM92_TCRIT_REG;
	write[1] = (uint8_t)((TCrit >> 8) & 0xff);
	write[2] = (uint8_t)(TCrit & 0xff);
	data.dir = I2C_WriteOnly;
	data.slave = Lm92Addrs[index];
	data.write = write;
	data.read  = NULL;
	data.wLen  = 3;
	data.rLen  = 0;

	ret = I2C_Transmit(I2C1, data);

	return ret;
}

/*******************************************************************************
 * name: LM92GetManufacturerId
 * role: Get manufacturer ID form the LM92 chip
 * in: index -> 0/1/2
 * out: 0 if success else none 0
*******************************************************************************/
static uint32_t LM92GetManufacturerId(uint32_t index, uint16_t* id)
{
	I2C_TransmiData_t data;
	uint32_t ret = 0;
	uint8_t write[2];
	uint8_t read[2];

	write[0] = LM92_MF_ID_REG;
	data.dir = I2C_WriteRead;
	data.slave = Lm92Addrs[index];
	data.write = write;
	data.read  = read;
	data.wLen  = 1;
	data.rLen  = 2;
    
	ret = I2C_Transmit(I2C1, data);
    	
    *id = (uint16_t)(read[1] | (read[0]<<8));
    return ret;
}

/*******************************************************************************
 * name: LM92_GetTemp_Request()
 * role: return temp from the LM92 chip
 * in: void
 * out: 0 if no error, else none 0
*******************************************************************************/

void LM92_GetTemp_Request(void)
{
    LM92_GET_TEMP_FLAG = 1;		
}

/*******************************************************************************
 * name: LM92_GetId_Request()
 * role: return temp from the LM92 chip
 * in: void
 * out: 0 if no error, else none 0
*******************************************************************************/

void LM92_GetId_Request(void)
{
    LM92_GET_ID_FLAG = 1;		
}

/*******************************************************************************
 * name: LM92Management
 * role: manage the LM92 chip
 * in: void
 * out: 0 if no error, else none 0
*******************************************************************************/
static uint32_t LM92Management(void)
{
	uint32_t i=0;
	uint32_t ret = 0;
    int16_t temp[3];
    char sign = ' ';
    uint16_t Id[3];

    if(LM92_GET_TEMP_FLAG)
	{
        for(i=0; i<3; i++)
    	{
            ret = LM92ReadTemperature(i, &(temp[i]));
    	}

		if(LM92_SYMBOL_FLAG)
		{
		    sign = '+';
		}
		else
		{
		    sign = '-';
		}
		for(i = 0; i < 3; i++)
		{
	 	    sprintf((char *)CRC_BUFFER, "\r\nLM92 temperature[%d]:%c%d.%.4d\r\n",
                 	i, sign, temp[i] >> 4, (temp[i] & 0xF)*625);
    		    dbg_printf((char *)CRC_BUFFER);
		}
	 	LM92_GET_TEMP_FLAG = 0;
	}
    else if(LM92_GET_ID_FLAG)
    {
        for(i=0; i<3; i++)
    	{
            ret = LM92GetManufacturerId(i, &(Id[i]));
            
	        sprintf((char *)CRC_BUFFER, "LM92[%d] manufacturer ID:%04x\r\n", i, Id[i]);
	        dbg_printf((char *)CRC_BUFFER);
    	}
        LM92_GET_ID_FLAG = 0;
    }

	return ret;
}

/*******************************************************************************
 * name: INA220_WriteReg
 * role: Write a 16bit value to a register inside the INA220
 * in: address -> the register's offset
 * 	   value   -> the content of that register
 * out: 0 if no error, else none 0
 * note: The INA220 is mounted to the I2C3 bus
*******************************************************************************/
static uint32_t INA220_WriteReg(uint8_t address, uint16_t value)
{
	uint32_t error = 0;
	I2C_TransmiData_t data;
	uint8_t write[3];

	write[0] = address;
	write[1] = (uint8_t)((value & 0xff00) >> 8);
	write[2] = (uint8_t)(value & 0x00ff);

	data.dir = I2C_WriteOnly;
	data.slave = INA220_ADDRESS;
	data.write = write;
	data.read  = NULL;
	data.wLen  = 3;
	data.rLen  = 0;

	error = I2C_Transmit(I2C3, data);

	return error;
}

/*******************************************************************************
 * name: INA220_ReadReg
 * role: Read a 16bit value of a register
 * in: address -> the register's offset
 * 	   *value   -> the content of that register
 * out: 0 if no error, else none 0
 * note: The INA220 is mounted to the I2C3 bus
*******************************************************************************/
static uint32_t INA220_ReadReg(uint8_t address, uint16_t *value)
{
	uint32_t error = 0;
	I2C_TransmiData_t data;
	uint8_t write[1];
	uint8_t read[2];

	write[0] = address;

	data.dir = I2C_WriteRead;
	data.slave = INA220_ADDRESS;
	data.write = write;
	data.read  = read;
	data.wLen  = 1;
	data.rLen  = 2;

	error = I2C_Transmit(I2C3, data);

	*value = ((uint16_t)read[0]<<8) | (uint16_t)read[1];/* MSB */

	return error;
}


/*******************************************************************************
 * name: INA220_Configuration
 * role: set the INA220's configuration registers
 * in: void
 * out: 0 if no error, else none 0
 * note: The INA220 is mounted to the I2C3 bus
*******************************************************************************/
uint32_t INA220_Configuration(void)
{
	uint16_t cfg = 0;
	uint32_t error = 0;

	cfg |= (uint16_t)(INA220_CFG_BRNG<<INA220_CFG_BRNG_OFFSET);
	cfg |= (uint16_t)(INA220_CFG_PG<<INA220_CFG_PG_OFFSET);
	cfg |= (uint16_t)(INA220_CFG_BADC<<INA220_CFG_BADC_OFFSET);
	cfg |= (uint16_t)(INA220_CFG_SADC<<INA220_CFG_SADC_OFFSET);
	cfg |= (uint16_t)(INA220_CFG_MODE<<INA220_CFG_MODE_OFFSET);

	error = INA220_WriteReg(0, cfg);

	return error;
}

/*******************************************************************************
 * name: INA220_SetCurrentCalibration
 * role: set INA220's calibration register
 * in: calibration
 * out: 0 if no error, else none 0
 * note: The 0bit must be '0'
 *       The INA220 is mounted to the I2C3 bus
*******************************************************************************/
uint32_t INA220_SetCurrentCalibration(uint16_t calibration)
{
	uint32_t error = 0;

	calibration &= 0xfe;

	error = INA220_WriteReg(0x5, calibration);

	return error;
}

void INA220_GetMsg_Request(void)
{
    INA220_GET_MSG_FLAG = 1;		
}

uint32_t INA220Management(void)
{
	uint32_t error = 0;
	uint16_t vshunt;
	uint16_t vbus;
	uint16_t current;
	uint16_t power;
    uint16_t def_cfg;

    switch(Ina220State)
	{
	    case 0:
            error = INA220_ReadReg(INA220_REG_CFG, &def_cfg);
            sprintf((char *)CRC_BUFFER, "INA220 def cfg:0x%04x \r\n", (unsigned short)def_cfg);
		    dbg_printf((char *)CRC_BUFFER);
            
		    INA220_Configuration();
		    INA220_SetCurrentCalibration(INA220_CALIBRATION);
		    Ina220State = 1;
		    dbg_printf("INA220_Configuration...\r\n");
		    break;
	    case 1:
            if(INA220_GET_MSG_FLAG)
            {
		        INA220_GET_MSG_FLAG = 0;
		        error = INA220_ReadReg(INA220_REG_VSHUNT, &vshunt);
		        vshunt = vshunt * 10; /* 1LSB = 10uV */
                sprintf((char *)CRC_BUFFER, "INA220 Vshunt is %04d uV\r\n", (unsigned int)vshunt);
		        dbg_printf((char *)CRC_BUFFER);

		        error = INA220_ReadReg(INA220_REG_VBUS, &vbus);
		        vbus = vbus >> 3;/* 3 LSB is not used */
		        vbus = vbus << 2; /* VBUS 1LSB=4mV */
		        sprintf((char *)CRC_BUFFER, "INA220 Vbus is %04d mv\r\n", (unsigned int)vbus);
		        dbg_printf((char *)CRC_BUFFER);

		        error = INA220_ReadReg(INA220_REG_CURRENT, &current);
		        sprintf((char *)CRC_BUFFER, "INA220 Current is %04dmA\r\n", (unsigned int)current);
		        dbg_printf((char *)CRC_BUFFER);

		        error = INA220_ReadReg(INA220_REG_POWER, &power);
		        power = power * 20; /* 1LSB = 20mW */
		        sprintf((char *)CRC_BUFFER, "INA220 Power is %04d mW\r\n", (unsigned int)power);
		        dbg_printf((char *)CRC_BUFFER);
            }
		    break;
	    case 2:
		    break;
	    default:
		    break;
	}

	return error;
}

/*******************************************************************************
 * name: AT24C02UpdateAddressPointer
 * role: Update the address pointer of the AT24C02 chip
 * in: chip -> the slave address
 *     addr -> the destination address
 * out: 0 if success else none 0
*******************************************************************************/
uint32_t AT24C02UpdateAddressPointer(uint8_t chip, uint8_t addr)
{
	uint32_t error = 0;
	I2C_TransmiData_t data;
	uint8_t write[1];

	write[0] = addr;

	data.dir = I2C_WriteOnly;
	data.slave = chip;
	data.write = write;
	data.read  = NULL;
	data.wLen  = 1;
	data.rLen  = 0;

	error = I2C_Transmit(I2C3, data);

	return error;
}

/*******************************************************************************
 * name: AT24C02CurrentReadByte
 * role: read a byte from the address which pointed by the internal pointer
 * in: chip -> the slave address
 *     *vale -> keep the read data
 * out: 0 if success else none 0
*******************************************************************************/
uint32_t AT24C02CurrentReadByte(uint8_t chip, uint8_t *value)
{
	uint32_t error = 0;
	I2C_TransmiData_t data;

	data.dir = I2C_ReadOnly;
	data.slave = chip;
	data.write = NULL;
	data.read  = value;
	data.wLen  = 0;
	data.rLen  = 1;

	error = I2C_Transmit(I2C3, data);

	return error;
}

/*******************************************************************************
 * name: AT24C02RandomReadBytes
 * role: read len bytes from AT24C02 at random position
 * in: chip -> the slave address
 *     addr -> the random position inside AT24C02
 *     pdata -> pointer which store the reading data
 *     len -> how many bytes will be read
 * out: 0 if no error, else none 0
 * note: the address of reading will roll over at the end of the chip size
*******************************************************************************/
static uint32_t AT24C02RandomReadBytes(uint8_t chip, uint8_t addr, uint8_t *pdata, uint8_t len)
{
	uint32_t error = 0;
	I2C_TransmiData_t data;

	if(!len)
	{
		goto out;
	}

	data.dir = I2C_WriteRead;
	data.slave = chip;
	data.write = &addr;
	data.read  = pdata;
	data.wLen  = 1;
	data.rLen  = len;

	error = I2C_Transmit(I2C3, data);
out:
	return error;
}


/*******************************************************************************
 * name: AT24C02RandomWriteBytes
 * role: read len bytes from AT24C02 at random position
 * in: chip -> the slave address
 *     addr -> the random position inside AT24C02
 *     pdata -> pointer which store the reading data
 *     len -> how many bytes will be read
 * out: 0 if no error, else none 0
 * note: the address of writing will roll over at the end of each page
 * constrain: len must not greater than page size
*******************************************************************************/
static uint32_t AT24C02RandomWriteBytes(uint8_t chip, uint8_t addr, uint8_t *pdata, uint8_t len)
{
	static uint8_t page_buffer[AT24C02_PAGE_SIZE+1]={0};
	uint32_t error = 0;
	I2C_TransmiData_t data;

	if(!len || len > AT24C02_PAGE_SIZE)
	{
		goto out;
	}

	page_buffer[0] = addr;
	memcpy(&page_buffer[1], pdata, len);

	/* write data to the destination */
	data.dir = I2C_WriteOnly;
	data.slave = chip;
	data.write = page_buffer;
	data.read  = NULL;
	data.wLen  = len+1; /* append the address byte */
	data.rLen  = 0;

	error = I2C_Transmit(I2C3, data);
	vTaskDelay(6); /* wait 5ms for the EEPROM finished the write operation */

out:
	return error;
}


/*******************************************************************************
 * name: AT24C02Read
 * role: read len bytes from AT24C02 at random position
 * in: chip -> the slave address
 *     addr -> the random position inside AT24C02
 *     pdata -> pointer which store the reading data
 *     len -> how many bytes will be read
 * out: 0 if no error, else none 0
 * note: the address of reading will roll over at the end of the chip
*******************************************************************************/
uint32_t AT24C02Read(uint8_t chip, uint8_t address, uint8_t *data, uint8_t len)
{
	uint32_t error = 0;
	uint32_t end = 0;

	end = (uint32_t)address + (uint32_t)len;

	if(end > AT24C02_CHIP_SIZE-1)
	{
		error = 1;
	}

	if(!error)
	{
		error = AT24C02RandomReadBytes(chip, address, data, len);

	}

	return error;
}

/*******************************************************************************
 * name: AT24C02Write
 * role: read len bytes from AT24C02 at random position
 * in: chip -> the slave address
 *     addr -> the random position inside AT24C02
 *     pdata -> pointer which store the reading data
 *     len -> how many bytes will be read
 * out: 0 if no error, else none 0
 * note: the address of writing will roll over at the end of each page
*******************************************************************************/
uint32_t AT24C02Write(uint8_t chip, uint8_t address, uint8_t *data, uint8_t len)
{
	uint32_t error = 0;
	uint32_t end = 0;
	uint32_t left = 0;
	uint32_t page = 0;
	uint32_t head = 0;

	if(!len)
	{
		goto out;
	}

	end = (uint32_t)address + (uint32_t)len;

	if(end > (AT24C02_CHIP_SIZE-1))
	{
		error = 1;
		goto out;
	}

	left = (uint32_t) len;

	page = (uint32_t)((uint32_t)address & (~(AT24C02_PAGE_SIZE - 1)));

	head = AT24C02_PAGE_SIZE - ((uint32_t)address - (uint32_t)page);

	if(head)
	{
		/* the first part which does not page aligned */
		error = AT24C02RandomWriteBytes(chip, address, data, (uint8_t) head);

		address = page + AT24C02_PAGE_SIZE;/* address point to page boundary */
		left -= head;
		data += head;
	}
	/* read page aligned data */
	while (!error && left >= AT24C02_PAGE_SIZE)
	{
		error = AT24C02RandomWriteBytes(chip, address, data, AT24C02_PAGE_SIZE);
		address += AT24C02_PAGE_SIZE;
		data += AT24C02_PAGE_SIZE;
		left -= AT24C02_PAGE_SIZE;
	}

	/* read the remaining data */
	if (!error && left)
	{
		error = AT24C02RandomWriteBytes(chip, address, data, left);
		address += left;
		data += left;
		left = 0;
	}
out:
	return error;
}

/*******************************************************************************
 * name: AT24C64UpdateAddressPointer
 * role: Update the address pointer of the AT24C64 chip
 * in: chip -> the slave address
 *     addr -> the destination address
 * out: 0 if success else none 0
*******************************************************************************/
uint32_t AT24C64UpdateAddressPointer(uint8_t chip, uint16_t addr)
{
	uint32_t error = 0;
	I2C_TransmiData_t data;
	uint8_t write[2];

	write[0] = (uint8_t)(addr & 0xff00)>>8;/*MSB*/
	write[1] = (uint8_t)(addr & 0xff);/*LSB*/

	data.dir = I2C_WriteOnly;
	data.slave = chip;
	data.write = write;
	data.read  = NULL;
	data.wLen  = 2;
	data.rLen  = 0;

	error = I2C_Transmit(I2C1, data);

	return error;
}

/*******************************************************************************
 * name: AT24C64CurrentReadByte
 * role: read a byte from the address which pointed by the internal pointer
 * in: chip -> the slave address
 *     *vale -> keep the read data
 * out: 0 if success else none 0
*******************************************************************************/
uint32_t AT24C64CurrentReadByte(uint8_t chip, uint8_t *value)
{
	uint32_t error = 0;
	I2C_TransmiData_t data;

	data.dir = I2C_ReadOnly;
	data.slave = chip;
	data.write = NULL;
	data.read  = value;
	data.wLen  = 0;
	data.rLen  = 1;

	error = I2C_Transmit(I2C1, data);

	return error;
}

/*******************************************************************************
 * name: AT24C64RandomReadBytes
 * role: read len bytes from AT24C64 at random position
 * in: chip -> the slave address
 *     addr -> the random position inside AT24C64
 *     pdata -> pointer which store the reading data
 *     len -> how many bytes will be read
 * out: 0 if no error, else none 0
 * note: the address of reading will roll over at the end of the chip size
*******************************************************************************/
static uint32_t AT24C64RandomReadBytes(uint8_t chip, uint16_t addr, uint8_t *pdata, uint16_t len)
{
	uint32_t error = 0;
	I2C_TransmiData_t data;
	uint8_t write[2];

	if(!len)
	{
		goto out;
	}
	write[0] = (uint8_t)((addr & 0xff00)>>8);
	write[1] = (uint8_t)(addr & 0xff);

	data.dir = I2C_WriteRead;
	data.slave = chip;
	data.write = write;
	data.read  = pdata;
	data.wLen  = 2;
	data.rLen  = len;

	error = I2C_Transmit(I2C1, data);
out:
	return error;
}

/*******************************************************************************
 * name: AT24C64RandomWriteBytes
 * role: read len bytes from AT24C64 at random position
 * in: chip -> the slave address
 *     addr -> the random position inside AT24C64
 *     pdata -> pointer which store the reading data
 *     len -> how many bytes will be read
 * out: 0 if no error, else none 0
 * note: the address of writing will roll over at the end of each page
 * constrain: len must not greater than page size
*******************************************************************************/
static uint32_t AT24C64RandomWriteBytes(uint8_t chip, uint16_t addr, uint8_t *pdata, uint16_t len)
{
	static uint8_t page_buffer[AT24C64_PAGE_SIZE+2]={0};
	uint32_t error = 0;
	I2C_TransmiData_t data;

	if(!len || len > AT24C64_PAGE_SIZE)
	{
		goto out;
	}

	page_buffer[0] = (uint8_t)((addr>>8) & 0xff);/* MSB address */
	page_buffer[1] = (uint8_t)(addr & 0xff);/* LSB address */
	memcpy(&page_buffer[2], pdata, len);
	/* write data to the destination */
	data.dir = I2C_WriteOnly;
	data.slave = chip;
	data.write = page_buffer;
	data.read  = NULL;
	data.wLen  = len+2;
	data.rLen  = 0;

	error = I2C_Transmit(I2C1, data);

	vTaskDelay(6); /* wait 5ms for the EEPROM finished the write operation */
out:
	return error;
}

/*******************************************************************************
 * name: AT24C64Read
 * role: read len bytes from AT24C64 at random position
 * in: chip -> the slave address
 *     addr -> the random position inside AT24C64
 *     data -> pointer which store the reading data
 *     len -> how many bytes will be read
 * out: 0 if no error, else none 0
 * note: the address of reading will roll over at the end of the chip
*******************************************************************************/
uint32_t AT24C64Read(uint8_t chip, uint16_t address, uint8_t *data, uint16_t len)
{
	uint32_t error = 0;
	uint32_t end = 0;

	end = (uint32_t)address + (uint32_t)len;



	if(end > (AT24C64_CHIP_SIZE-1))
	{
		error = 1;
	}

	if(!error)
	{
		error = AT24C64RandomReadBytes(chip, address, data, len);
	}

	return error;
}

/*******************************************************************************
 * name: AT24C64Write
 * role: read len bytes from AT24C64 at random position
 * in: chip -> the slave address
 *     addr -> the random position inside AT24C64
 *     pdata -> pointer which store the reading data
 *     len -> how many bytes will be read
 * out: 0 if no error, else none 0
 * note: the address of writing will roll over at the end of each page
*******************************************************************************/
uint32_t AT24C64Write(uint8_t chip, uint16_t address, uint8_t *data, uint16_t len)
{
	uint32_t error = 0;
	uint32_t end = 0;
	uint32_t left = 0;
	uint32_t page = 0;
	uint32_t head = 0;

	if(!len)
	{
		goto out;
	}

	end = (uint32_t)address + (uint32_t)len;

	if(end > AT24C64_CHIP_SIZE-1)
	{
		error = 1;
		goto out;
	}

	left = (uint32_t) len;

	page = (uint32_t)((uint32_t)address & (~(AT24C64_PAGE_SIZE - 1)));

	head = AT24C64_PAGE_SIZE - ((uint32_t)address - (uint32_t)page);

	if (head)
	{
		/* the first part which does not page aligned */
		error = AT24C64RandomWriteBytes(chip, address, data, (uint16_t) head);

		address = page + AT24C64_PAGE_SIZE;/* address point to page boundary */
		left -= head;
		data += head;
	}

	/* read page aligned data */
	while (!error && left >= AT24C64_PAGE_SIZE)
	{
		error = AT24C64RandomWriteBytes(chip, address, data, AT24C64_PAGE_SIZE);
		address += AT24C64_PAGE_SIZE;
		data += AT24C64_PAGE_SIZE;
		left -= AT24C64_PAGE_SIZE;
	}

	/* read the remaining data */
	if (!error && left)
	{
		error = AT24C64RandomWriteBytes(chip, address, data, left);
		address += left;
		data += left;
		left = 0;
	}
out:
	return error;
}


/*******************************************************************************
 * name: Adt7461GetManufacturerId
 * role: Get manufacturer ID form the adt7461 chip
 * out: 0 if success else none 0
*******************************************************************************/
static uint32_t Adt7461GetManufacturerId(uint8_t *id)
{
	I2C_TransmiData_t data;
	uint32_t ret = 0;
	uint8_t write[2];
	uint8_t read[1];

	write[0] = ADT7461_MF_ID_REG;
	data.dir = I2C_WriteRead;
	data.slave = ADT7461_ADDRESS;
	data.write = write;
	data.read  = read;
	data.wLen  = 1;
    data.rLen  = 1;

    ret = I2C_Transmit(I2C3, data);
    *id = read[0];

//    sprintf((char *)CRC_BUFFER, "ADT7461 manufacturer ID:%x \r\n", read[0]);
//	dbg_printf((char *)CRC_BUFFER);

	return ret;
}

/*******************************************************************************
 * name: Adt7461Read_LTV_Register
 * role: read local temperature value from the ADT7461 chip
*******************************************************************************/
static int Adt7461Read_LTV_Register(int32_t *temp_val)
{
	I2C_TransmiData_t data;
	uint32_t ret = 0;
	uint8_t write[2] = {ADT7461_LTV_REG};
	uint8_t read[1];
	int32_t temperature = 0;

	data.dir = I2C_WriteRead;
	data.slave = ADT7461_ADDRESS;
	data.write = write;
	data.read  = read;
	data.wLen  = 1;
	data.rLen  = 1;

	ret = I2C_Transmit(I2C3, data);
    temperature = (int32_t)read[0];
    *temp_val = temperature;
    
//   sprintf((char *)CRC_BUFFER, "Adt7461 local temperture:%d \r\n",(int)temperature);
//				dbg_printf((char *)CRC_BUFFER);

	return ret;
}
/*******************************************************************************
 * name: Adt7461Read_ETVHB_Register
 * role: read external temperature value high byte from the ADT7461 chip
*******************************************************************************/
static int Adt7461Read_ETVHB_Register(uint32_t *extemp_val_highbyte)
{
	I2C_TransmiData_t data;
	uint32_t ret = 0;
	uint8_t write[2] = {ADT7461_ETVHB_REG};
	uint8_t read[1];
	int32_t temperature = 0;

	data.dir = I2C_WriteRead;
	data.slave = ADT7461_ADDRESS;
	data.write = write;
	data.read  = read;
	data.wLen  = 1;
	data.rLen  = 1;

	ret = I2C_Transmit(I2C3, data);
    
    *extemp_val_highbyte = (unsigned int)read[0];

//  sprintf((char *)CRC_BUFFER, "Adt7461 external temperature value high byte:%x \r\n", (unsigned int)read[0]);
//	dbg_printf((char *)CRC_BUFFER);

	return ret;
}

/*******************************************************************************
 * name: Adt7461Read_ETVLB_Register
 * role: read external temperature value low byte from the ADT7461 chip
*******************************************************************************/
static int Adt7461Read_ETVLB_Register(uint32_t *extemp_val_lowbyte)
{
	I2C_TransmiData_t data;
	uint32_t ret = 0;
	uint8_t write[2] = {ADT7461_ETVLB_REG};
	uint8_t read[1];
	int32_t temperature = 0;

	data.dir = I2C_WriteRead;
	data.slave = ADT7461_ADDRESS;
	data.write = write;
	data.read  = read;
	data.wLen  = 1;
	data.rLen  = 1;

	ret = I2C_Transmit(I2C3, data);

    *extemp_val_lowbyte = (unsigned int)read[0];
//  sprintf((char *)CRC_BUFFER, "Adt7461 external temperature value low byte:%x \r\n",(unsigned int)read[0]);
//	dbg_printf((char *)CRC_BUFFER);

	return ret;
}

/*******************************************************************************
 * name: Adt7461Read_ETOHB_Register
 * role: read external temperature offset High byte from the ADT7461 chip
*******************************************************************************/
static int Adt7461Read_ETOHB_Register(uint32_t *extemp_offset_highbyte)
{
	I2C_TransmiData_t data;
	uint32_t ret = 0;
	uint8_t write[2] = {Ext_Offset_H_Reg};
	uint8_t read[1];
	int32_t temperature = 0;

	data.dir = I2C_WriteRead;
	data.slave = ADT7461_ADDRESS;
	data.write = write;
	data.read  = read;
	data.wLen  = 1;
	data.rLen  = 1;

	ret = I2C_Transmit(I2C3, data);

    *extemp_offset_highbyte = (unsigned int)read[0];
//  sprintf((char *)CRC_BUFFER, "Adt7461 external temperature offset high byte:%x \r\n",(unsigned int)read[0]);
//	dbg_printf((char *)CRC_BUFFER);

	return ret;
}

/*******************************************************************************
 * name: Adt7461Read_ETOHB_Register
 * role: read external temperature offset High byte from the ADT7461 chip
*******************************************************************************/
static int Adt7461Read_ETOLB_Register(uint32_t *extemp_offset_lowbyte)
{
	I2C_TransmiData_t data;
	uint32_t ret = 0;
	uint8_t write[2] = {Ext_Offset_L_Reg};
	uint8_t read[1];
	int32_t temperature = 0;

	data.dir = I2C_WriteRead;
	data.slave = ADT7461_ADDRESS;
	data.write = write;
	data.read  = read;
	data.wLen  = 1;
	data.rLen  = 1;

	ret = I2C_Transmit(I2C3, data);

    *extemp_offset_lowbyte = (unsigned int)read[0];
//  sprintf((char *)CRC_BUFFER, "Adt7461 external temperature offset low byte:%x \r\n",(unsigned int)read[0]);
//	dbg_printf((char *)CRC_BUFFER);

	return ret;
}

/*******************************************************************************
 * name: ADT7461_Measu_Charge            added by lgy  20170428
 * role:   modify the ADT7461 of range
 * in: void^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 * out: 0 if success else none 0
*******************************************************************************/
static uint32_t ADT7461_Measu_Charge(void)
{
	I2C_TransmiData_t data;
	uint32_t ret = 0;
	uint8_t write[2];
	uint8_t read[2];

	write[0] = Config_Write_Reg;
	write[1] = 0x04;
	data.dir = I2C_WriteOnly;
	data.slave = ADT7461_ADDRESS;
	data.write = write;
	data.read  = read;
	data.wLen  = 2;
	data.rLen  = 0;

	ret = I2C_Transmit(I2C2, data);

	return ret;
}

static uint32_t ADT7461_Read_Config(void)
{
	I2C_TransmiData_t data;
	uint32_t ret = 0;
	uint8_t write[2];
	uint8_t read[2];

	write[0] = Config_Read_Reg;
	//write[1] = 0x44;
	data.dir = I2C_WriteRead;
	data.slave = ADT7461_ADDRESS;
	data.write = write;
	data.read  = read;
	data.wLen  = 1;
	data.rLen  = 1;

	ret = I2C_Transmit(I2C2, data);
	return ret;
}

/*******************************************************************************
 * name: ADT7461_Conv_Charge            added by lgy  20170427
 * role:    Charge the rate of ADC
 * in:       uint8_t rate
 * out:    0 if success else none 0
*******************************************************************************/
static uint32_t ADT7461_Conv_Charge(uint8_t rate)
{
	I2C_TransmiData_t data;
	uint32_t ret = 0;
	uint8_t write[2];
	uint8_t read[2];
	write[0] = Conv_Write_Reg;
	write[1] = rate;
	data.dir = I2C_WriteOnly;
	data.slave = ADT7461_ADDRESS;
	data.write = write;
	data.read  = read;
	data.wLen  = 2;
	data.rLen  = 0;

	ret = I2C_Transmit(I2C2, data);
        //ret_data=data[0];
	//sprintf((char *)CRC_BUFFER, "ADT7461 manufacturer ID:0X%x\r\n",
	//		(unsigned int)read[0]);
	//dbg_printf((char *)CRC_BUFFER);

	return ret;
}
/*******************************************************************************
 * name: ADT7461_Offset_Value            added by lgy  20170427
 * role:    Add the Offset Value
 * in:       the offset value of temperature(NOTE: if interger = -6, decimal = 0 you may get a good effects)
 * out:    0 if success else none 0
*********************************************************/
static uint32_t ADT7461_Offset_Value(int8_t integer ,uint8_t decimal)
{
	I2C_TransmiData_t data;
	uint32_t ret = 0;
	int8_t write[2];
	uint8_t read[2];
        int8_t ret_data;
	write[0] = Ext_Offset_H_Reg;
	write[1] =integer;
	data.dir = I2C_WriteOnly;
	data.slave = ADT7461_ADDRESS;
	data.write = write;
	data.read  = read;
	data.wLen  = 2;
	data.rLen  = 0;
	ret = I2C_Transmit(I2C3, data);
	if(1==ret)
		return ret;

	write[0] = Ext_Offset_L_Reg;
	write[1] =decimal;
	data.dir = I2C_WriteOnly;
	data.slave = ADT7461_ADDRESS;
	data.write = write;
	data.read  = read;
	data.wLen  = 2;
	data.rLen  = 0;
	ret = I2C_Transmit(I2C3, data);
        //ret_data=read[0];
	//sprintf(FPGA_Temp_DebugBuffer, "ADT7461 Local Temperature :  %d\r\n",
			//(unsigned int)read[0]);
	//dbg_printf(FPGA_Temp_DebugBuffer);

	return ret;
}

/*******************************************************************************
 * name: ADT7461_Get_Id_Request()
 * role: return temp from the ADT7461 chip
 * in: void
 * out: 0 if no error, else none 0
*******************************************************************************/

void ADT7461_Get_Id_Request(void)
{
    ADT7461_GET_ID_FLAG = 1;		
}

/*******************************************************************************
 * name: ADT7461_Get_Local_Temp_Request()
 * role: return temp from the ADT7461 chip
 * in: void
 * out: 0 if no error, else none 0
*******************************************************************************/

void ADT7461_Get_Local_Temp_Request(void)
{
    ADT7461_GET_LOCAL_TEMP_FLAG = 1;		
}

/*******************************************************************************
 * name: ADT7461_Get_Extemp_High_Byte_Request()
 * role: return temp from the ADT7461 chip
 * in: void
 * out: 0 if no error, else none 0
*******************************************************************************/

void ADT7461_Get_Extemp_High_Byte_Request(void)
{
    ADT7461_GET_EXTEMP_HIGH_BYTE_FLAG = 1;		
}

/*******************************************************************************
 * name: ADT7461_Get_Extemp_Low_Byte_Request()
 * role: return temp from the ADT7461 chip
 * in: void
 * out: 0 if no error, else none 0
*******************************************************************************/

void ADT7461_Get_Extemp_Low_Byte_Request(void)
{
    ADT7461_GET_EXTEMP_LOW_BYTE_FLAG = 1;		
}

/*******************************************************************************
 * name: ADT7461_Get_Ex_Offset_H_Byte_Request()
 * role: return External Temp offset High byte from the ADT7461 chip
 * in: void
 * out: 0 if no error, else none 0
*******************************************************************************/

void ADT7461_Get_Ex_Offset_H_Byte_Request(void)
{
    ADT7461_GET_Ex_Offset_H_BYTE_FLAG = 1;		
}

/*******************************************************************************
 * name: ADT7461_Get_Ex_Offset_H_Byte_Request()
 * role: return External Temp offset High byte from the ADT7461 chip
 * in: void
 * out: 0 if no error, else none 0
*******************************************************************************/

void ADT7461_Get_Ex_Offset_L_Byte_Request(void)
{
    ADT7461_GET_Ex_Offset_L_BYTE_FLAG = 1;		
}

/*******************************************************************************
 * name: ADT7461_Set_Ex_Offset_Request()
 * role: return External Temp offset Low byte from the ADT7461 chip
 * in: void
 * out: 0 if no error, else none 0
*******************************************************************************/

void ADT7461_Set_Ex_Offset_Request(int8_t integer, uint8_t decimal)
{
    ADT7461_SET_Ex_Offset_FLAG = 1;	
#if 0
    sprintf((char *)CRC_BUFFER, "Adt7461 offset integer:%d \r\n", integer);
	dbg_printf((char *)CRC_BUFFER);

    sprintf((char *)CRC_BUFFER, "Adt7461 offset decimal:%d \r\n", decimal);
	dbg_printf((char *)CRC_BUFFER);
#endif
}


/*******************************************************************************
 * name: Adt7461Management
 * role: manage the ADT7621 chip
 * in: void
 * out: 0 if no error, else none 0
*******************************************************************************/
static uint32_t Adt7461Management(void)
{
	uint32_t i=0;
	uint32_t ret = 0;
    uint8_t adt7461_id;
    int32_t local_temp_value;
    uint32_t extemp_high_byte_value;
    uint32_t extemp_low_byte_value;
    uint32_t ex_offset_h_byte;
    uint32_t ex_offset_l_byte;
    	
	if(ADT7461_GET_ID_FLAG)
	{
        Adt7461GetManufacturerId(&adt7461_id);
		sprintf((char *)CRC_BUFFER, "ADT7461: 0x%04x\r\n", adt7461_id);
		dbg_printf((char *)CRC_BUFFER);
        ADT7461_GET_ID_FLAG = 0;
    }
    if(ADT7461_GET_LOCAL_TEMP_FLAG)
    {
        Adt7461Read_LTV_Register(&local_temp_value);
         
        sprintf((char *)CRC_BUFFER, "Adt7461 local temperture:%d \r\n", local_temp_value);
	    dbg_printf((char *)CRC_BUFFER);
        ADT7461_GET_LOCAL_TEMP_FLAG = 0;
    }
    if(ADT7461_GET_EXTEMP_HIGH_BYTE_FLAG)
    {
        Adt7461Read_ETVHB_Register(&extemp_high_byte_value);
        sprintf((char *)CRC_BUFFER, "Adt7461 external temperature value high byte:%x \r\n", extemp_high_byte_value);
	    dbg_printf((char *)CRC_BUFFER);
        ADT7461_GET_EXTEMP_HIGH_BYTE_FLAG = 0;
    }

    if(ADT7461_GET_EXTEMP_LOW_BYTE_FLAG)
    {
        Adt7461Read_ETVLB_Register(&extemp_low_byte_value);
        sprintf((char *)CRC_BUFFER, "Adt7461 external temperature value low byte:%x \r\n", extemp_low_byte_value);
	    dbg_printf((char *)CRC_BUFFER);

        ADT7461_GET_EXTEMP_LOW_BYTE_FLAG = 0;
    }

    if(ADT7461_GET_Ex_Offset_H_BYTE_FLAG)
    {
        Adt7461Read_ETOHB_Register(&ex_offset_h_byte);
        sprintf((char *)CRC_BUFFER, "Adt7461 external temperature offset high byte:%x \r\n", ex_offset_h_byte);
	    dbg_printf((char *)CRC_BUFFER);

        ADT7461_GET_Ex_Offset_H_BYTE_FLAG = 0;
    }

    if(ADT7461_GET_Ex_Offset_L_BYTE_FLAG)
    {
        Adt7461Read_ETOLB_Register(&ex_offset_l_byte);
        sprintf((char *)CRC_BUFFER, "Adt7461 external temperature offset low byte:%x \r\n", ex_offset_l_byte);
	    dbg_printf((char *)CRC_BUFFER);

        ADT7461_GET_Ex_Offset_L_BYTE_FLAG = 0;
    }

    if(ADT7461_SET_Ex_Offset_FLAG)
    {
        ADT7461_Offset_Value(adt7461_offset_integer, adt7461_offset_decimal);
        ADT7461_SET_Ex_Offset_FLAG = 0; 
    }

	return ret;
}


void AT24C02Test(uint8_t address)
{
	uint32_t i;
	uint32_t error = 0;
	static uint8_t At24C02Buffer[AT24C02_PAGE_SIZE*4];

	for(i=0; i<sizeof(At24C02Buffer); i++)
	{
		At24C02Buffer[i] = (uint8_t)i;
	}

	error = AT24C02Write(AT24C02_CHIP1, address, At24C02Buffer, sizeof(At24C02Buffer));

	if(error)
	{
		dbg_printf("AT24C02 write failed!\n\r");
	}
	else
	{
		memset(At24C02Buffer, 0, sizeof(At24C02Buffer));
		error = AT24C02Read(AT24C02_CHIP1, address, At24C02Buffer, sizeof(At24C02Buffer));
		if(error)
		{
			dbg_printf("AT24C02 read failed!\r\n");
		}
		else
		{
			for(i=0; i<sizeof(At24C02Buffer); i++)
			{
				if(At24C02Buffer[i] != i)
				{
					dbg_printf("AT24C02 data verify failed!\r\n");
					break;
				}
			}
		}
        dbg_printf("AT24C02 data verify succeed!\r\n");
	}
}


void AT24C64Test(uint16_t address)
{
	uint32_t i;
	uint32_t error = 0;
	static uint8_t At24C64Buffer[AT24C64_PAGE_SIZE*4];

	sprintf((char *)CRC_BUFFER, "AT24C64 Testing at %x:%x\r\n", address, sizeof(At24C64Buffer));
	dbg_printf((char *)CRC_BUFFER);

	for(i=0; i<sizeof(At24C64Buffer); i++)
	{
		At24C64Buffer[i] = (uint8_t)i;
	}

	error = AT24C64Write(AT24C64_CHIP1, address, At24C64Buffer, sizeof(At24C64Buffer));

	if(error)
	{
		dbg_printf("AT24C64 write failed!\n\r");
	}
	else
	{
		memset(At24C64Buffer, 0, sizeof(At24C64Buffer));
		error = AT24C64Read(AT24C64_CHIP1, address, At24C64Buffer, sizeof(At24C64Buffer));
		if(error)
		{
			dbg_printf("AT24C64 read failed!\r\n");
		}
		else
		{
			for(i=0; i<sizeof(At24C64Buffer); i++)
			{
				if(At24C64Buffer[i] != i)
				{
					dbg_printf("AT24C64 data verify failed!\r\n");
					break;
				}
			}
		}
        dbg_printf("AT24C64 data verify succeed!\r\n");
	}
}

void AT24C02_TestRequest(uint8_t addr)
{
	Eeprom_state = 1;
	Eeprom_TestAddr = (uint32_t)addr;
}

void AT24C64_TestRequest(uint16_t addr)
{
	Eeprom_state = 2;
	Eeprom_TestAddr = (uint32_t)addr;
}

void EEPROM_Manamagement(void)
{
	switch(Eeprom_state)
	{
	case 0:
		break;
	case 1:
		AT24C02Test(Eeprom_TestAddr);
		Eeprom_state = 0;;
		break;
	case 2:
		AT24C64Test(Eeprom_TestAddr);
		Eeprom_state = 0;
		break;
	}
}

void Task4(void* p)
{
	uint8_t tmp;
	static uint32_t error=0;
	static int count = 0;
    static uint32_t index = 1;

	/* T Turn-on = T init + n 1 ∙T POL + n 2 ∙T AD*/
	/*T Init = 11.5ms*/
	/*T POL = 26.5ms*/
	/*T AD = 7.5ms*/
	/*n 1 = total number of POL regulators in the system*/
	/*n 2 = total number of Auxiliary Devices in the system*/
	vTaskDelay(50);

	while(1)
	{
		if(dpm_getflag(DPM_FLAG0))
		{
			dpm_resetflag(DPM_FLAG0);
			if(dpm_dump_pol(reg_pol_cache1, sizeof(reg_pol_cache1)))
			{
				error |= DPM_FLAG0;
			}
			else
			{
				error &= ~DPM_FLAG0;
			}
		}

		if(dpm_getflag(DPM_FLAG1))
		{
			dpm_resetflag(DPM_FLAG1);
			if(dpm_dump_dpm(reg_dpm_cache1, sizeof(reg_dpm_cache1)))
			{
				error |= DPM_FLAG1;
			}
			else
			{
				error &= ~DPM_FLAG1;
			}
		}

		if(dpm_getflag(DPM_FLAG2))
		{
			dpm_resetflag(DPM_FLAG2);
			if(dpm_run(1))
			{
				dbg_printf("DM7304 Output failed!\r\n");
				error |= DPM_FLAG2;
			}
			else
			{
				dbg_printf("DM7304 Output done!\r\n");
				error &= ~DPM_FLAG2;
			}
		}

		if(dpm_getflag(DPM_FLAG4))
		{
			dpm_resetflag(DPM_FLAG4);
			dpm_disable_wp(0x02);
			delay(1);
			if(dpm_program_pol())
			{
				error |= DPM_FLAG4;
				dbg_printf("DM7304 program POL failed!\r\n");
			}
			else
			{
				dbg_printf("DM7304 program POL done!\r\n");
				error &= ~DPM_FLAG4;
			}
		}

		if(dpm_getflag(DPM_FLAG3))
		{
			dpm_resetflag(DPM_FLAG3);
			dpm_disable_wp(0x20);
			delay(1);
			if(dpm_program_dpm())
			{
				error |= DPM_FLAG3;
				dbg_printf("DM7304 program DPM failed!\r\n");
			}
			else
			{
				error &= ~DPM_FLAG3;
				dbg_printf("DM7304 program DPM done!\r\n");
			}
		}

		if(dpm_getflag(DPM_FLAG5))
		{
			dpm_resetflag(DPM_FLAG5);
			if(!dpm_disable_wp(0x8))
			{
				if (dpm_program_pol_ram())
				{
					error |= DPM_FLAG5;
				}
				else
				{
					error &= ~DPM_FLAG5;
				}
			}
		}
		/* print DM7304 status to UART */
		if(dpm_getflag(DPM_FLAG6))
		{
			dpm_resetflag(DPM_FLAG6);
			if (dpm_rmdp(0, &pol_status))
			{
				dbg_printf("Read Monitoring Data of single POL Failed!\r\n");
			}
			sprintf((char *)CRC_BUFFER, "pol_status.st %x\r\n", pol_status.st);
			dbg_printf((char *)CRC_BUFFER);
			sprintf((char *)CRC_BUFFER, "pol_status.vh %x\r\n", pol_status.vh);
			dbg_printf((char *)CRC_BUFFER);
			sprintf((char *)CRC_BUFFER, "pol_status.vl %x\r\n", pol_status.vl);
			dbg_printf((char *)CRC_BUFFER);
			sprintf((char *)CRC_BUFFER, "pol_status.io %x\r\n", pol_status.io);
			dbg_printf((char *)CRC_BUFFER);
			sprintf((char *)CRC_BUFFER, "pol_status.tmp %x\r\n", pol_status.tmp);
			dbg_printf((char *)CRC_BUFFER);

			if(dpm_rsm(&dpm_status))
			{
				dbg_printf("Read Status Monitoring Data Failed!\r\n");
			}
			sprintf((char *)CRC_BUFFER, "dpm_status.sta %x\r\n", dpm_status.sta);
			dbg_printf((char *)CRC_BUFFER);
			sprintf((char *)CRC_BUFFER, "dpm_status.stb %x\r\n", dpm_status.stb);
			dbg_printf((char *)CRC_BUFFER);
			sprintf((char *)CRC_BUFFER, "dpm_status.stc %x\r\n", dpm_status.stc);
			dbg_printf((char *)CRC_BUFFER);
			sprintf((char *)CRC_BUFFER, "dpm_status.std %x\r\n", dpm_status.std);
			dbg_printf((char *)CRC_BUFFER);
			sprintf((char *)CRC_BUFFER, "dpm_status.dpms %x\r\n", dpm_status.dpms);
			dbg_printf((char *)CRC_BUFFER);
			sprintf((char *)CRC_BUFFER, "dpm_status.est %x\r\n", dpm_status.est);
			dbg_printf((char *)CRC_BUFFER);

			if(dpm_rpss(&pol_pss))
			{
				dbg_printf("Read POL Status Summary Failed!\r\n");
			}
			sprintf((char *)CRC_BUFFER, "pol_pss.pss0 %x\r\n", pol_pss.pss0);
			dbg_printf((char *)CRC_BUFFER);
			sprintf((char *)CRC_BUFFER, "pol_pss.pss1 %x\r\n", pol_pss.pss1);
			dbg_printf((char *)CRC_BUFFER);
			sprintf((char *)CRC_BUFFER, "pol_pss.pss2 %x\r\n", pol_pss.pss2);
			dbg_printf((char *)CRC_BUFFER);
			sprintf((char *)CRC_BUFFER, "pol_pss.pss3 %x\r\n", pol_pss.pss3);
			dbg_printf((char *)CRC_BUFFER);

			if(dpm_rrp(0x15, &tmp))
			{
				dbg_printf("Read POL run status Failed!\r\n");
			}
			sprintf((char *)CRC_BUFFER, "run %x\r\n", tmp);
			dbg_printf((char *)CRC_BUFFER);
		}

		if(dpm_getflag(DPM_FLAG9))
		{
			dpm_resetflag(DPM_FLAG9);
			if(dpm_run(0))
			{
				error |= DPM_FLAG9;
				dbg_printf("DM7304 stopped failed!\r\n");
			}
			else
			{
				error &= ~DPM_FLAG9;
				dbg_printf("DM7304 stopped done!\r\n");
			}
		}

        PCA9555_Management();
		INA220Management();
		EEPROM_Manamagement();
		LM92Management();
        Adt7461Management();
		vTaskDelay(500); /* 500ms */
		GPIO_SetBits(GPIOA, GPIO_Pin_15);
	}

	vTaskDelete(NULL);
}
