/* this task is the driver for the lmk04031 */

#include "multi-task.h"
#include "FreeRTOS.h"
#include "task1.h"
#include "task3.h"
#include "task6.h"
#include "debug.h"
#include "stm32f4xx_spi.h"
#include "stm32f4xx_usart.h"
#include "init.h"
#include "ad9548_regs.h"

#include "b53_priv.h"
#include "semphr.h"
#include "stm32f4xx_tim.h"

#define B53_SPI_DATA		0xf0

#define B53_SPI_STATUS		0xfe
#define B53_SPI_CMD_SPIF	BIT(7)
#define B53_SPI_CMD_RACK	BIT(5)

#define B53_SPI_CMD_READ	0x00
#define B53_SPI_CMD_WRITE	0x01
#define B53_SPI_CMD_NORMAL	0x60
#define B53_SPI_CMD_FAST	0x10

#define B53_SPI_PAGE_SELECT	0xff

#define AD9548_SPI_CMD_READ_BYTE	    0x8000
#define AD9548_SPI_CMD_WRITE_BYTE	        0x0000
#define AD9548_DEVICE_ID        0x0003
#define AD9548_SPI_CONCTL       0x0000
#define AD9548_SPI_IO_UPDATE    0x0005
#define AD9548_SPI_N_DIVIDER    0x0101
#define AD9548_SYSCLK_STATUS    0x0D01
#define AD9548_DPLL_STATUS      0x0D0A
#define AD9548_AREF_STATUS      0x0D0B
#define AD9548_INPUT_REF_A_STATUS  0x0D0C

#define AD9548_CONCTL_CFG       0x90
#define AD9548_IO_UPDATE_CFG    0x01
#define AD9548_N_DIVIDER_CFG    0x32


static uint32_t ad9548_flag = 0;

#define AD9548_GET_ID_FLAG      1
#define AD9548_READ_DIVIDER_FLAG    2
#define AD9548_WRITE_DIVIDER_FLAG   3
#define AD9548_READ_SYSCLK_STATUS_FLAG   4
#define AD9548_READ_DPLL_STATUS_FLAG   5
#define AD9548_READ_INPUT_REF_STATUS_FLAG   6
#define AD9548_CFG_122_88MHZ_FLAG   7

StackType_t Task3Stack[TASK3_STACK_SIZE] CCM_RAM;  // Put task stack in CCM
StaticTask_t Task3Buffer CCM_RAM;  // Put TCB in CCM

char Task3DebugBuffer[64];
char FlagDebugBuffer[64];
#ifdef SEMAPHORE_TEST
SemaphoreHandle_t UartxSemaphore;
#endif/*SEMAPHORE_TEST*/

const uint32_t lmk04031_cfg_info_25M[] =
{
  /* uBPA 25M input*/
  //R7 RESET bit = 1 This ensures that the device is configured with default settings.
  0x00000017,
  //Program R0 through R4 to configure the clock channel functions such as the channel multiplexer output
  //selection, divide value, delay value, and enable/disable bit.
  0x01030500,
  0x010B0101,
  0x01780102,
  0x010B0103,
  0x01030104,
  0x00000005,
  0x08000076,
  //Program R7 with RESET = 0.
  0x00000007,
  0x00000008,
  0x00A22A09,
  //Program R10 with the default values
  0x0150000A,
  //Program R11 to configure the reference clock inputs
  0x0065081B,
  //Program R12 to configure PLL1
  0xF271C00C,
  //Program R13 through R15 to configure PLL2 parameters,
  //crystal mode options, and certain globally asserted functions.
  0x0A04000D,
  0x0F77002E,
  //end data
  0x1D40005F // 0x1D40005F
};

const uint32_t lmk04031_cfg_info_10M[] =
{
  /*  10M backpanel  */
  //R7 RESET bit = 1 This ensures that the device is configured with default settings.
  0x00000017,
  //Program R0 through R4 to configure the clock channel functions such as the channel multiplexer output
  //selection, divide value, delay value, and enable/disable bit.
  0x01030500,
  0x010B0101,
  0x01780102,
  0x010B0103,
  0x01030104,
  0x00000005,
  0x08000076,
  //Program R7 with RESET = 0.
  0x00000007,
  0x00000008,
  0x00A22A09,
  //Program R10 with the default values
  0x0150000A,
  //Program R11 to configure the reference clock inputs
  0x0065000B,//0x0065081B,
  //Program R12 to configure PLL1
  0xF0FAC00C,//0xF271C00C,
  //Program R13 through R15 to configure PLL2 parameters,
  //crystal mode options, and certain globally asserted functions.
  0x0A04000D,
  0x0F77002E, //BIT<20:16> PLL_MUX ,  PLL1&2LDH:10111, PLL1LDH:01110
  //end data
  0x1D40005F
};

/* the below registers are generated by tool */
const uint32_t lmk04031_cfg_info_10M_122p88M[] = {
    0x00000017,
    0x01030300,
    0x01080101,
    0x01080102,
    0x01080103,
    0x01000104,
    0x00000005,
    0x08000076,
    0x00000007,
    0x00000008,
    0x00A22A09,
    0x0150000A,
    0x00650DCB,
    0xF07D600C,
    0x0A04000D,
    0x0F77002E,
    0x1C8000CF
};

/*******************************************************************************
 * name: SpiByteTransmit
 * role: send/receive 8 bits from the SPI3 bus
 * params: in -> point to the data which send to the bus
 *         out -> point to the data which store the received byte
 * return: 0 if ok, else none 0
 * 	   THigh
 * note: the data bus width 8bits/16bits was set by the SPI_Init
*******************************************************************************/
uint32_t SpiTransmit(uint8_t *tx, uint8_t *rx)
{
	uint16_t data;
	uint32_t ret = 1;
	uint32_t counter = 1000;
	static uint32_t lock = 0;

	/* in case multi-task are using the SPI3 bus, wait until it finished */
	while(lock > 0);
	lock ++;/* increase the lock */

	data = (uint16_t)*tx;
	/* wait SPI TX to finish */
	while ((SPI_I2S_GetFlagStatus(SPI3, SPI_I2S_FLAG_TXE) == RESET) && counter--);

	if(counter)
	{
		/* send data to SPI bus */
		SPI_I2S_SendData(SPI3, data);
		counter = 1000;
		while ((SPI_I2S_GetFlagStatus(SPI3, SPI_I2S_FLAG_RXNE) == RESET) && counter--);
		*rx =  (uint8_t)(SPI_I2S_ReceiveData(SPI3) & 0xff);

		if(counter)
		{
			ret = 0;
		}
	}

	lock --;/* decrease the lock */

	return ret;
}

uint16_t Lmk04031WriteTowByte(uint16_t data)
{
	uint8_t hl, ll, rec;

	hl = (uint8_t)((data >> 8) & 0xff);
	ll = (uint8_t)(data & 0xff);

	SpiTransmit(&hl, &rec);/* disregard the received byte */
	SpiTransmit(&ll, &rec);/* disregard the received byte */

	return 0;
}

uint16_t Lmk04031WriteReg(uint32_t reg)
{
#ifdef SPI3_CS_SW_MODE
	GPIO_ResetBits(GPIOA, GPIO_Pin_4); /* SPI CS low */
#endif/*SPI3_CS_SW_MODE*/
	Lmk04031WriteTowByte((uint16_t)(reg>>16)&0xffff);
	Lmk04031WriteTowByte((uint16_t)(reg)&0xffff);
#ifdef SPI3_CS_SW_MODE
	/* the CS pin shall be set the high then low level for at least 25ns */
	GPIO_SetBits(GPIOA, GPIO_Pin_4); /* SPI CS high */
	udelay(1);	
	GPIO_ResetBits(GPIOA, GPIO_Pin_4); /* SPI CS low */
#endif/*SPI3_CS_SW_MODE*/

	return 0;
}

uint16_t Lmk04031Configure10M(void)
{
	int i;
	for(i=0; i<sizeof(lmk04031_cfg_info_10M)/sizeof(lmk04031_cfg_info_10M[0]); i++)
	{
		Lmk04031WriteReg(lmk04031_cfg_info_10M[i]);
	}

	return 0;
}

/* CLKIN0 single-ended input 10MHz, OSCIN:122.88MHz, CLKOUT0:122.88MHz */
uint16_t Lmk04031Configure10M_122p88MHz(void)
{
	int i;
	for(i=0; i<sizeof(lmk04031_cfg_info_10M_122p88M)/sizeof(lmk04031_cfg_info_10M_122p88M[0]); i++)
	{
		Lmk04031WriteReg(lmk04031_cfg_info_10M_122p88M[i]);
	}

	return 0;
}

uint16_t Lmk04031Configure25M(void)
{
	int i;
	for(i=0; i<sizeof(lmk04031_cfg_info_25M)/sizeof(lmk04031_cfg_info_25M[0]); i++)
	{
		Lmk04031WriteReg(lmk04031_cfg_info_25M[i]);
	}

	return 0;
}


static inline int b53_spi_read_reg(uint8_t reg, uint8_t *val,
				     unsigned len)
{
	uint32_t error = 0;
	uint8_t txbuf[2];
	uint8_t rxbuf;
	uint32_t i;

	txbuf[0] = B53_SPI_CMD_NORMAL | B53_SPI_CMD_READ;
	txbuf[1] = reg;

	GPIO_ResetBits(GPIOA, GPIO_Pin_4); /* SPI CS low */
	/* send read command + address */
	for(i=0; i<sizeof(txbuf); i++)
	{
		error = SpiTransmit(&txbuf[i], &rxbuf);
		if(error)
		{
			break;
		}
	}
	if(!error)
	{
		for(i=0; i<len; i++)
		{
			txbuf[0] = 0xff;/* dump TX */
			error = SpiTransmit(&txbuf[0], val++);
			if(error)
			{
				break;
			}
		}
	}
	GPIO_SetBits(GPIOA, GPIO_Pin_4); /* SPI CS high */

	return error;
}

static inline int b53_spi_clear_status(void)
{
	unsigned int i;
	uint8_t rxbuf;
	int ret;

	for (i = 0; i < 10; i++) {
		ret = b53_spi_read_reg(B53_SPI_STATUS, &rxbuf, 1);
		if (ret)
			return ret;

		if (!(rxbuf & B53_SPI_CMD_SPIF))
			break;

		vTaskDelay(1);
	}

	if (i == 10)
		return -1;

	return 0;
}

static inline int b53_spi_set_page(uint8_t page)
{
	uint8_t txbuf[3];
	uint32_t i;
	int error = 0;
    uint8_t rxbuf;

	txbuf[0] = B53_SPI_CMD_NORMAL | B53_SPI_CMD_WRITE;
	txbuf[1] = B53_SPI_PAGE_SELECT;
	txbuf[2] = page;

	GPIO_ResetBits(GPIOA, GPIO_Pin_4); /* SPI CS low */
	for(i=0; i<sizeof(txbuf); i++)
	{
		error = SpiTransmit(&txbuf[i], &rxbuf);
		if(error)
		{
			break;
		}
	}
	GPIO_SetBits(GPIOA, GPIO_Pin_4); /* SPI CS high */


	return error;
}

static inline int b53_prepare_reg_access(uint8_t page)
{
	int ret = b53_spi_clear_status();
	if (ret)
		return ret;

	return b53_spi_set_page(page);
}

static int b53_spi_prepare_reg_read(uint8_t reg)
{
	uint8_t rxbuf;
	int retry_count;
	int ret;

	ret = b53_spi_read_reg(reg, &rxbuf, 1);
	if (ret)
		return ret;

	for (retry_count = 0; retry_count < 10; retry_count++) {
		ret = b53_spi_read_reg(B53_SPI_STATUS, &rxbuf, 1);
		if (ret)
			return ret;

		if (rxbuf & B53_SPI_CMD_RACK)
			break;

		vTaskDelay(1);
	}

	if (retry_count == 10)
		return -1;

	return 0;
}

static int b53_spi_read(uint8_t page, uint8_t reg, uint8_t *data,
			unsigned len)
{
	int ret;

	ret = b53_prepare_reg_access(page);
	if (ret)
		return ret;

	ret = b53_spi_prepare_reg_read(reg);
	if (ret)
		return ret;

	return b53_spi_read_reg(B53_SPI_DATA, data, len);
}

static int b53_spi_read8(uint8_t page, uint8_t reg, uint8_t *val)
{
	return b53_spi_read(page, reg, val, 1);
}

static int b53_spi_read16(uint8_t page, uint8_t reg, uint16_t *val)
{
	int ret = b53_spi_read(page, reg, (uint8_t *)val, 2);
//	if (!ret)
//		*val = le16_to_cpu(*val);

	return ret;
}

static int b53_spi_read32(uint8_t page, uint8_t reg, uint32_t *val)
{
	int ret = b53_spi_read(page, reg, (u8 *)val, 4);
//	if (!ret)
//		*val = le32_to_cpu(*val);

	return ret;
}

static int b53_spi_read48(uint8_t page, uint8_t reg, uint64_t *val)
{
	int ret;

	*val = 0;
	ret = b53_spi_read(page, reg, (uint8_t *)val, 6);
//	if (!ret)
//		*val = le64_to_cpu(*val);

	return ret;
}

static int b53_spi_read64(uint8_t page, uint8_t reg, uint64_t *val)
{
	int ret = b53_spi_read(page, reg, (uint8_t *)val, 8);
//	if (!ret)
//		*val = le64_to_cpu(*val);

	return ret;
}

static int b53_spi_write8(uint8_t page, uint8_t reg, uint8_t value)
{
	int ret;
	uint32_t i;
	uint8_t txbuf[3];
	uint8_t rxbuf;

	ret = b53_prepare_reg_access(page);
	if (ret)
		return ret;

	txbuf[0] = B53_SPI_CMD_NORMAL | B53_SPI_CMD_WRITE;
	txbuf[1] = reg;
	txbuf[2] = value;

	GPIO_ResetBits(GPIOA, GPIO_Pin_4); /* SPI CS low */
	for(i=0; i<sizeof(txbuf); i++)
	{
		ret = SpiTransmit(&txbuf[i], &rxbuf);
		if(ret)
		{
			break;
		}
	}
	GPIO_SetBits(GPIOA, GPIO_Pin_4); /* SPI CS high */

	return ret;
}

static int b53_spi_write16(uint8_t page, uint8_t reg, uint16_t value)
{
	int ret;
	int i;
	uint8_t txbuf[4];
	uint8_t rxbuf;

	ret = b53_prepare_reg_access(page);
	if (ret)
		return ret;

	txbuf[0] = B53_SPI_CMD_NORMAL | B53_SPI_CMD_WRITE;
	txbuf[1] = reg;
	txbuf[2] = (uint8_t)(value & 0xff);
	txbuf[3] = (uint8_t)((value >> 8) & 0xff);
//	put_unaligned_le16(value, &txbuf[2]);

	GPIO_ResetBits(GPIOA, GPIO_Pin_4); /* SPI CS low */
	for(i=0; i<sizeof(txbuf); i++)
	{
		ret = SpiTransmit(&txbuf[i], &rxbuf);
		if(ret)
		{
			break;
		}
	}
	GPIO_SetBits(GPIOA, GPIO_Pin_4); /* SPI CS high */

	return ret;
}

static int b53_spi_write32(uint8_t page, uint8_t reg, uint32_t value)
{
	int ret;
	int i;
	u8 txbuf[6];
	uint8_t rxbuf;

	ret = b53_prepare_reg_access(page);
	if (ret)
		return ret;

	txbuf[0] = B53_SPI_CMD_NORMAL | B53_SPI_CMD_WRITE;
	txbuf[1] = reg;
	txbuf[2] = (uint8_t)(value & 0xff);
	txbuf[3] = (uint8_t)((value >> 8 )& 0xff);
	txbuf[4] = (uint8_t)((value >> 16) & 0xff);
	txbuf[5] = (uint8_t)((value >> 24) & 0xff);
//	put_unaligned_le32(value, &txbuf[2]);

	GPIO_ResetBits(GPIOA, GPIO_Pin_4); /* SPI CS low */
	for(i=0; i<sizeof(txbuf); i++)
	{
		ret = SpiTransmit(&txbuf[i], &rxbuf);
		if(ret)
		{
			break;
		}
	}
	GPIO_SetBits(GPIOA, GPIO_Pin_4); /* SPI CS high */

	return ret;
}

static int b53_spi_write48(uint8_t page, uint8_t reg, uint64_t value)
{
	int ret;
	int i;
	uint8_t txbuf[10];
	uint8_t rxbuf;

	ret = b53_prepare_reg_access(page);
	if (ret)
		return ret;

	txbuf[0] = B53_SPI_CMD_NORMAL | B53_SPI_CMD_WRITE;
	txbuf[1] = reg;
	txbuf[2] = (uint8_t)(value & 0xff);
	txbuf[3] = (uint8_t)((value >> 8 )& 0xff);
	txbuf[4] = (uint8_t)((value >> 16) & 0xff);
	txbuf[5] = (uint8_t)((value >> 24) & 0xff);
	txbuf[6] = (uint8_t)((value >> 32) & 0xff);
	txbuf[7] = (uint8_t)((value >> 40) & 0xff);
//	put_unaligned_le64(value, &txbuf[2]);

	GPIO_ResetBits(GPIOA, GPIO_Pin_4); /* SPI CS low */
	for(i=0; i<sizeof(txbuf); i++)
	{
		ret = SpiTransmit(&txbuf[i], &rxbuf);
		if(ret)
		{
			break;
		}
	}
	GPIO_SetBits(GPIOA, GPIO_Pin_4); /* SPI CS high */

	return ret;
}

static int b53_spi_write64(uint8_t page, uint8_t reg, uint64_t value)
{
	int ret;
	int i;
	uint8_t txbuf[10];
	uint8_t rxbuf;

	ret = b53_prepare_reg_access(page);
	if (ret)
		return ret;

	txbuf[0] = B53_SPI_CMD_NORMAL | B53_SPI_CMD_WRITE;
	txbuf[1] = reg;
	txbuf[2] = (uint8_t)(value & 0xff);
	txbuf[3] = (uint8_t)((value >> 8 )& 0xff);
	txbuf[4] = (uint8_t)((value >> 16) & 0xff);
	txbuf[5] = (uint8_t)((value >> 24) & 0xff);
	txbuf[6] = (uint8_t)((value >> 32) & 0xff);
	txbuf[7] = (uint8_t)((value >> 40) & 0xff);
	txbuf[8] = (uint8_t)((value >> 48) & 0xff);
	txbuf[9] = (uint8_t)((value >> 56) & 0xff);
//	put_unaligned_le64(value, &txbuf[2]);

	GPIO_ResetBits(GPIOA, GPIO_Pin_4); /* SPI CS low */
	for(i=0; i<sizeof(txbuf); i++)
	{
		ret = SpiTransmit(&txbuf[i], &rxbuf);
		if(ret)
		{
			break;
		}
	}
	GPIO_SetBits(GPIOA, GPIO_Pin_4); /* SPI CS high */

	return ret;
}

int32_t B5396_GetId(uint8_t *id)
{
	int32_t error = 0;

	error = b53_spi_read8(B53_MGMT_PAGE, B53_DEVICE_ID, id);

	if(!error)
	{
		sprintf(Task3DebugBuffer, "BCM5396 ID:%x\r\n", *id);
		dbg_printf(Task3DebugBuffer);
	}

	return error;
}

int32_t B5396_GetBPDUMulticastAdd(uint8_t *addr)
{
	int32_t error = 0;

	error = b53_spi_read48(B53_ARLCTRL_PAGE, 4, (uint64_t *)addr);

	if(!error)
	{
		sprintf(Task3DebugBuffer, "BCM5396 MultiCastAdd:%x %x %x %x %x %x\r\n", addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
		dbg_printf(Task3DebugBuffer);
	}

	return error;
}

int32_t B5396_GetAgeTimeCfg(uint32_t *sec)
{
	int32_t error = 0;

	error = b53_spi_read32(B53_MGMT_PAGE, B53_AGE_TIME, sec);

	if(!error)
	{
		sprintf(Task3DebugBuffer, "BCM5396 Age time:%x\r\n", *sec);
		dbg_printf(Task3DebugBuffer);
	}

	return error;
}

int32_t B5396_SetAgeTimeCfg(uint32_t sec)
{
	int32_t error = 0;

	error = b53_spi_write32(B53_MGMT_PAGE, B53_AGE_TIME, sec);

	return error;
}

static inline int ad9548_spi_write_reg(uint16_t reg, uint8_t val)
{
	uint32_t error = 0;
	uint8_t txbuf[3];
	uint8_t rxbuf;
	uint32_t i;
    uint16_t instruct_head;


    instruct_head = (uint16_t)(reg | AD9548_SPI_CMD_WRITE_BYTE);
    
    txbuf[0] = (uint8_t)((((uint16_t)instruct_head) >> 8) & 0xff);
    txbuf[1] = (uint8_t)(((uint16_t)instruct_head) & 0xff);
    txbuf[2] = (uint8_t)(val);

	/* send write command + address + val */ 
	for(i=0; i<sizeof(txbuf); i++)
	{
		error = SpiTransmit(&txbuf[i], &rxbuf);
		if(error)
		{
			break;
		}
	}

	return error;
}

static inline int ad9548_spi_read_reg(uint16_t reg, uint8_t *val,
				     unsigned len)
{
	uint32_t error = 0;
	uint8_t txbuf[2];
	uint8_t rxbuf;
	uint32_t i;
    uint16_t instruct_head;
    
    instruct_head = (uint16_t)(reg | AD9548_SPI_CMD_READ_BYTE);

    txbuf[0] = (uint8_t)((((uint16_t)instruct_head) >> 8) & 0xff);
    txbuf[1] = (uint8_t)(((uint16_t)instruct_head) & 0xff);


//    txbuf[0] = (uint8_t)((((uint16_t)0x8101) >> 8) & 0xff);
//    txbuf[1] = (uint8_t)(((uint16_t)0x8101) & 0xff);


	/* send read command + address */
	for(i=0; i<sizeof(txbuf); i++)
	{
		error = SpiTransmit(&txbuf[i], &rxbuf);
		if(error)
		{
			break;
		}
	}
	if(!error)
	{
		for(i=0; i<len; i++)
		{
			txbuf[0] = 0xff;/* dump TX */
			error = SpiTransmit(&txbuf[0], val++);
			if(error)
			{
				break;
			}
		}
	}

	return error;
}


static int ad9548_spi_read8(uint16_t reg, uint8_t *val)
{
   
    return ad9548_spi_read_reg(reg, val, 1);
}

static int ad9548_spi_write8(uint16_t reg, uint8_t val)
{
   
    return ad9548_spi_write_reg(reg, val);
}



int32_t AD9548_GetId(uint8_t *id)
{
	int32_t error = 0;
    int32_t ret = 0;

#ifdef SPI3_CS_SW_MODE
	GPIO_ResetBits(GPIOA, GPIO_Pin_4); /* SPI CS low */
#endif/*SPI3_CS_SW_MODE*/

    error = ad9548_spi_write8(AD9548_SPI_CONCTL, AD9548_CONCTL_CFG);
    
    error = ad9548_spi_read8(AD9548_DEVICE_ID, id);

    if(!error)
	{
		sprintf(Task3DebugBuffer, "AD9548 ID:%x\r\n", *id);
		dbg_printf(Task3DebugBuffer);
	}
    else 
    {
		sprintf(Task3DebugBuffer, "error:%x\r\n", error);
		dbg_printf(Task3DebugBuffer);
    }


#ifdef SPI3_CS_SW_MODE
	GPIO_SetBits(GPIOA, GPIO_Pin_4); /* SPI CS high */
#endif/*SPI3_CS_SW_MODE*/
	return error;
}

int32_t AD9548_Read_Divider(uint8_t *div_val)
{
	int32_t error = 0;
    int32_t ret = 0;

#ifdef SPI3_CS_SW_MODE
	GPIO_ResetBits(GPIOA, GPIO_Pin_4); /* SPI CS low */
#endif/*SPI3_CS_SW_MODE*/

    error = ad9548_spi_write8(AD9548_SPI_CONCTL, AD9548_CONCTL_CFG);
    
    error = ad9548_spi_read8(AD9548_SPI_N_DIVIDER, div_val);

	if(!error)
	{
		sprintf(Task3DebugBuffer, "AD9548 N-divider:%x\r\n", *div_val);
		dbg_printf(Task3DebugBuffer);
	}
    else 
    {
		sprintf(Task3DebugBuffer, "error:%x\r\n", error);
		dbg_printf(Task3DebugBuffer);
    }

#ifdef SPI3_CS_SW_MODE
	GPIO_SetBits(GPIOA, GPIO_Pin_4); /* SPI CS high */
#endif/*SPI3_CS_SW_MODE*/
	return error;
}


void AD9548_GetId_Request(void)
{
    ad9548_flag = AD9548_GET_ID_FLAG;
    
}

void AD9548_Read_Divider_Request(void)
{
    ad9548_flag = AD9548_READ_DIVIDER_FLAG;		
}

void AD9548_Write_Divider_Request(void)
{
    ad9548_flag = AD9548_WRITE_DIVIDER_FLAG;		
}

void AD9548_Read_Sysclk_Status_Request(void)
{
    ad9548_flag = AD9548_READ_SYSCLK_STATUS_FLAG;		
}

void AD9548_Read_DPLL_Status_Request(void)
{
    ad9548_flag = AD9548_READ_DPLL_STATUS_FLAG;		
}

void AD9548_Read_Input_Ref_Status_Request(void)
{
    ad9548_flag = AD9548_READ_INPUT_REF_STATUS_FLAG;		
}

void AD9548_Cfg_122_88Mhz_Request(void)
{
    ad9548_flag = AD9548_CFG_122_88MHZ_FLAG;		
}


int32_t AD9548_Read_Divider_After_Write(uint8_t *div_val)
{
	int32_t error = 0;
    int32_t ret = 0;

#ifdef SPI3_CS_SW_MODE
	GPIO_ResetBits(GPIOA, GPIO_Pin_4); /* SPI CS low */
#endif/*SPI3_CS_SW_MODE*/

    error = ad9548_spi_write8(AD9548_SPI_CONCTL, AD9548_CONCTL_CFG);
    
    error = ad9548_spi_write8(AD9548_SPI_N_DIVIDER,AD9548_N_DIVIDER_CFG);
    
    error = ad9548_spi_write8(AD9548_SPI_IO_UPDATE, AD9548_IO_UPDATE_CFG);
    
    error = ad9548_spi_read8(AD9548_SPI_N_DIVIDER, div_val);

	if(!error)
	{
		sprintf(Task3DebugBuffer, "AD9548 new N-divider:%x\r\n", *div_val);
		dbg_printf(Task3DebugBuffer);
	}
    else 
    {
		sprintf(Task3DebugBuffer, "error:%x\r\n", error);
		dbg_printf(Task3DebugBuffer);
    }

#ifdef SPI3_CS_SW_MODE
	GPIO_SetBits(GPIOA, GPIO_Pin_4); /* SPI CS high */
#endif/*SPI3_CS_SW_MODE*/
	return error;
}

int32_t AD9548_Read_SYSCLK_Status(uint8_t *status)
{
	int32_t error = 0;
    int32_t ret = 0;

#ifdef SPI3_CS_SW_MODE
	GPIO_ResetBits(GPIOA, GPIO_Pin_4); /* SPI CS low */
#endif/*SPI3_CS_SW_MODE*/

    error = ad9548_spi_write8(AD9548_SPI_CONCTL, AD9548_CONCTL_CFG);

    error = ad9548_spi_read8(AD9548_SYSCLK_STATUS, status);

    if(!error)
	{
		sprintf(Task3DebugBuffer, "AD9548 SYSCLK status:%x\r\n", *status);
		dbg_printf(Task3DebugBuffer);
	}
    else 
    {
		sprintf(Task3DebugBuffer, "error:%x\r\n", error);
		dbg_printf(Task3DebugBuffer);
    }

    if(((*status)>>4)&0x01)
    {
        sprintf(Task3DebugBuffer, "AD9548 system clock stable\r\n");
		dbg_printf(Task3DebugBuffer);

    }
    else
    {
        sprintf(Task3DebugBuffer, "AD9548 system clock not stable\r\n");
		dbg_printf(Task3DebugBuffer);

    }

    if((*status)&0x01)
    {
        sprintf(Task3DebugBuffer, "AD9548 system clock locked\r\n");
		dbg_printf(Task3DebugBuffer);

    }
    else
    {
        sprintf(Task3DebugBuffer, "AD9548 system clock not locked\r\n");
		dbg_printf(Task3DebugBuffer);

    }


#ifdef SPI3_CS_SW_MODE
	GPIO_SetBits(GPIOA, GPIO_Pin_4); /* SPI CS high */
#endif/*SPI3_CS_SW_MODE*/
	return error;
}

int32_t AD9548_Read_DPLL_Status(uint8_t *status)
{
	int32_t error = 0;
    int32_t ret = 0;

#ifdef SPI3_CS_SW_MODE
	GPIO_ResetBits(GPIOA, GPIO_Pin_4); /* SPI CS low */
#endif/*SPI3_CS_SW_MODE*/

    error = ad9548_spi_write8(AD9548_SPI_CONCTL, AD9548_CONCTL_CFG);
    
    error = ad9548_spi_read8(AD9548_DPLL_STATUS, status);
    if(!error)
	{
		sprintf(Task3DebugBuffer, "AD9548 DPLL status:%x\r\n", *status);
		dbg_printf(Task3DebugBuffer);
	}
    else 
    {
		sprintf(Task3DebugBuffer, "error:%x\r\n", error);
		dbg_printf(Task3DebugBuffer);
    }
    
    if(((*status)>>5)&0x01)
    {
        sprintf(Task3DebugBuffer, "The DPLL has achieved frequency lock.\r\n");
		dbg_printf(Task3DebugBuffer);

    }
    else
    {
        sprintf(Task3DebugBuffer, "The DPLL has not achieved frequency lock.\r\n");
		dbg_printf(Task3DebugBuffer);

    }

    if(((*status)>>4)&0x01)
    {
        sprintf(Task3DebugBuffer, "The DPLL has achieved phase lock.\r\n");
		dbg_printf(Task3DebugBuffer);

    }
    else
    {
        sprintf(Task3DebugBuffer, "The DPLL has not achieved phase lock.\r\n");
		dbg_printf(Task3DebugBuffer);

    }

    if(((*status)>>2)&0x01)
    {
        sprintf(Task3DebugBuffer, "The DPLL is in holdover mode.\r\n");
		dbg_printf(Task3DebugBuffer);

    }
    else
    {
        sprintf(Task3DebugBuffer, "The DPLL is not in holdover mode.\r\n");
		dbg_printf(Task3DebugBuffer);

    }

    if(((*status)>>1)&0x01)
    {
        sprintf(Task3DebugBuffer, "The DPLL is active.\r\n");
		dbg_printf(Task3DebugBuffer);

    }
    else
    {
        sprintf(Task3DebugBuffer, "The DPLL is not active.\r\n");
		dbg_printf(Task3DebugBuffer);

    }

    if(((*status)>>0)&0x00)
    {
        sprintf(Task3DebugBuffer, "The DPLL is free running.\r\n");
		dbg_printf(Task3DebugBuffer);

    }
    else
    {
        sprintf(Task3DebugBuffer, "The DPLL is not  free running.\r\n");
		dbg_printf(Task3DebugBuffer);

    }

    error = ad9548_spi_read8(AD9548_AREF_STATUS, status);

    if(!error)
	{
		sprintf(Task3DebugBuffer, "AD9548 active ref status:%x\r\n", *status);
		dbg_printf(Task3DebugBuffer);
	}
    else 
    {
		sprintf(Task3DebugBuffer, "error:%x\r\n", error);
		dbg_printf(Task3DebugBuffer);
    }

    if((*status) == 0x40)
    {
        sprintf(Task3DebugBuffer, "The currently active reference is reference A.\r\n");
		dbg_printf(Task3DebugBuffer);

    }

#ifdef SPI3_CS_SW_MODE
	GPIO_SetBits(GPIOA, GPIO_Pin_4); /* SPI CS high */
#endif/*SPI3_CS_SW_MODE*/
	return error;
}

int32_t AD9548_Read_Input_Ref_Status(uint8_t *status)
{
	int32_t error = 0;
    int32_t ret = 0;

#ifdef SPI3_CS_SW_MODE
	GPIO_ResetBits(GPIOA, GPIO_Pin_4); /* SPI CS low */
#endif/*SPI3_CS_SW_MODE*/

    error = ad9548_spi_write8(AD9548_SPI_CONCTL, AD9548_CONCTL_CFG);

    error = ad9548_spi_read8(AD9548_INPUT_REF_A_STATUS, status);

    if(!error)
	{
		sprintf(Task3DebugBuffer, "AD9548 input reference A status:%x\r\n", *status);
		dbg_printf(Task3DebugBuffer);
	}
    else 
    {
		sprintf(Task3DebugBuffer, "error:%x\r\n", error);
		dbg_printf(Task3DebugBuffer);
    }

    if((((*status)>>3) & 0x01))
    {
        sprintf(Task3DebugBuffer, "Ref A is valid for use\r\n");
		dbg_printf(Task3DebugBuffer);
    }
    else
    {
        sprintf(Task3DebugBuffer, "Ref A is unfaulted\r\n");
		dbg_printf(Task3DebugBuffer);
    }


#ifdef SPI3_CS_SW_MODE
	GPIO_SetBits(GPIOA, GPIO_Pin_4); /* SPI CS high */
#endif/*SPI3_CS_SW_MODE*/
	return error;
}




uint16_t Ad9548Configure_122p88MHz(void)
{
    int i;
    int32_t error;
    uint32_t timeout;
    uint8_t status;

#ifdef SPI3_CS_SW_MODE
	    GPIO_ResetBits(GPIOA, GPIO_Pin_4); /* SPI CS low */
#endif/*SPI3_CS_SW_MODE*/
    
    for (i = 0; i <  sizeof(ad9548_cfg_info_122p88M)/sizeof(ad9548_cfg_info_122p88M[0]); i++)
    {
	    switch (ad9548_cfg_info_122p88M[i][0]) 
        {
		    case WAIT_B:
			    timeout = 100;
			    do {
                    error = ad9548_spi_read8(AD9548_SYSCLK_STATUS, &status);

				    if (status < 0)
                    {
		                dbg_printf("Read sysclk status error\r\n");
                        return error;
                    }
                    if (status & 0x01)
                    {   
		                dbg_printf("PLL lock sucess\r\n");
                        break;
                    }
                    vTaskDelay(1); /* 1ms */
                    } while (timeout--);

			    if (timeout <= 0)
                {
		            dbg_printf("timeout error\r\n");
                    return -1;
                }
                break;
		
            default:
                error =ad9548_spi_write8(ad9548_cfg_info_122p88M[i][0], ad9548_cfg_info_122p88M[i][1]);
			    
                if (error < 0)
                {
		            dbg_printf("Write cfg error\r\n");
				    return error;
			    }
                break;
		}
    }
    
#if 0
	for(i=0; i < sizeof(ad9548_cfg_info_122p88M)/sizeof(ad9548_cfg_info_122p88M[0]); i++)
	{
		error =ad9548_spi_write8(ad9548_cfg_info_122p88M[i][0], ad9548_cfg_info_122p88M[i][1]);
    }
#endif
#ifdef SPI3_CS_SW_MODE
	    GPIO_SetBits(GPIOA, GPIO_Pin_4); /* SPI CS high */
#endif/*SPI3_CS_SW_MODE*/


}


extern void Gpio2Test(void);
void Task3(void* p)
{
	static McuSpi3Mux_t Spi3Route;
	static int LmkInit = 0;
	static int BcmInit = 0;
    static int Ad9548Init = 0;

	uint8_t bcm5396id=0;
    uint8_t ad9548_id = 0;
    uint8_t ad9548_divider = 0;
    uint8_t ad9548_clk_status = 0;
    uint8_t ad9548_dpll_status = 0;
    uint8_t ad9548_input_ref_status = 0;
    McuSpi3Mux_t Route;

    while (Board_GetPowerStage() != PowerStage4)
    {
      vTaskDelay(20); /* period 20ms */
    }

	while (1)
	{
		Route = Fpga_GetMcuSpi3Sel();
		if(Route != Spi3Route)
		{
			/* MCU SPI3 routine changed, re-initialize the SPI bus */
			Spi3Route = Route;
			switch(Spi3Route)
			{
				case McuSpi3Mux_LMK04031:
					Init_Spi3(SPI_CPOL_Low, SPI_CPHA_1Edge);
					break;
				case McuSpi3Mux_BCM5396:
					Init_Spi3(SPI_CPOL_High, SPI_CPHA_2Edge);
					break;
				case McuSpi3Mux_AD9548:
					Init_Spi3(SPI_CPOL_High, SPI_CPHA_2Edge);
					break;
				default:
					break;
			}
		}

		switch(Spi3Route)
		{
			case McuSpi3Mux_LMK04031:/* LMK04031 initialization */
				if (!LmkInit)
				{
					LmkInit = 1;
					Lmk04031Configure10M_122p88MHz();
					dbg_printf("LMK 122.88MHz done!\r\n");
				}
				break;
			case McuSpi3Mux_BCM5396:/* BCM5396 initialization */
				if (!BcmInit)
				{
					uint8_t MultiCastAdd[6];
					uint32_t seconds = 0;
					BcmInit = 1;
					if(B5396_GetId(&bcm5396id) == 0)
					{
						char str[32];
						sprintf(str, "BCM5396 ID %x\r\n", bcm5396id);
						dbg_printf(str);
					}

					/* Read Write testing */
					B5396_GetBPDUMulticastAdd(MultiCastAdd);
					B5396_GetAgeTimeCfg(&seconds);
					seconds = 0x55aa;
					B5396_SetAgeTimeCfg(seconds);
					B5396_GetAgeTimeCfg(&seconds);
				}
				break;
			case McuSpi3Mux_AD9548:/* AD9548 initialization */
				if(!Ad9548Init)
				{
	                switch(ad9548_flag)
	                {
	                    case AD9548_GET_ID_FLAG:
					        AD9548_GetId(&ad9548_id);
	                        break;

	                    case AD9548_READ_DIVIDER_FLAG:
	                        AD9548_Read_Divider(&ad9548_divider);
	                        break;

	                    case AD9548_WRITE_DIVIDER_FLAG:
	                        AD9548_Read_Divider_After_Write(&ad9548_divider);
	                        break;

	                    case AD9548_READ_SYSCLK_STATUS_FLAG:
	                        AD9548_Read_SYSCLK_Status(&ad9548_clk_status);
	                        break;

                         case AD9548_READ_DPLL_STATUS_FLAG:
	                        AD9548_Read_DPLL_Status(&ad9548_dpll_status);
	                        break;

                         case AD9548_READ_INPUT_REF_STATUS_FLAG:
	                        AD9548_Read_Input_Ref_Status(&ad9548_input_ref_status);
	                        break;

	                    case AD9548_CFG_122_88MHZ_FLAG:
	                        Ad9548Configure_122p88MHz();
					        dbg_printf("ad9548 122.88MHz done!\r\n");
	                        break;

	                    default:
	                        break;

	                }
	                ad9548_flag = 0;
				}
				break;
			default:
				break;
		}
		
        vTaskDelay(200); /* period 200ms */
	}

	vTaskDelete(NULL);
}
